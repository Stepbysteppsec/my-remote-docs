#### ç³»ç»Ÿæ¦‚è¿°ï¼š
	å­˜åœ¨å®ä½“ tmsï¼Œå’Œzkï¼Œå…¶ä¸­zkæœ‰1-10ä¸ªã€‚è€Œtmsæœ‰ä¸€ä¸ªã€‚ zkå’Œtmsæœ‰å„è‡ªçš„åè®®ï¼Œæ‰€ä»¥å½“zkè¦å’Œtmsæ²Ÿé€šæ—¶éœ€è¦ä¸€ä¸ªä¸­é—´æ¡¥æ¢ç¨‹åº ï¼šBridge

#### ä¸»è¦æ ¸å¿ƒåœºæ™¯ï¼š

- æ”¶åˆ°zkå‘èµ·é€šå‘Šéœ€æ±‚ 
- brdigeè§£æé€šå‘Šéœ€æ±‚ï¼Œæå–target_id,ç­‰å‚æ•° 
- è½¬å‘é€šå‘Šéœ€æ±‚åˆ°tms
- å’Œtmså®Œæˆä¼šè¯ä¿¡ä»¤äº¤äº’è¿‡ç¨‹ ï¼ŒæˆåŠŸè¿›å…¥ä¸šåŠ¡é€šä¿¡
- å°†æ”¶åˆ°çš„zkçš„ä¸šåŠ¡é€šä¿¡ï¼Œè½¬å‘åˆ°å¯¹åº”çš„tmsä¾§çš„ç»ˆç«¯
- å°†æ”¶åˆ°çš„tmsä¾§çš„ä¸šåŠ¡é€šä¿¡è½¬å‘åˆ°å¯¹åº”çš„zk

- æ”¶åˆ°zk æ‹†é“¾é€šå‘Šéœ€æ±‚
- bridge è½¬å‘æ­¤éœ€æ±‚åˆ°tms
- tmså’Œbridgeæ‹†é“¾ä¿¡ä»¤äº¤äº’
- ä¸šåŠ¡é€šä¿¡æ‹†é™¤


##### è¯¦ç»†æ ¸å¿ƒåœºæ™¯æµç¨‹
- ç¨‹åºå¯åŠ¨
	- ä»é…ç½®æ–‡ä»¶ä¸­åŠ è½½cué…ç½®è¡¨ï¼Œcuå’Œtarget_idæ˜ å°„è¡¨
	-  åŠ è½½tms,zk çš„ip port åŒæ—¶å¯åŠ¨ç›‘å¬æµç¨‹
	- å’Œtmså»ºç«‹å¿ƒè·³ï¼Œå½“å­˜åœ¨å¿ƒè·³æ—¶ï¼Œä¸ŠæŠ¥è®¾å¤‡çŠ¶æ€åˆ°zk
- ç¨‹åºè¿è¡Œï¼š
	- ç›‘å¬åˆ°æ¥è‡ªzkçš„æŠ¥æ–‡
	- è¿™é‡Œå¥½åƒåè®®è‡ªå·±å°è£…äº†å¯é æ€§æœºåˆ¶
	- åˆ¤æ–­ç±»å‹ä¸º éœ€æ±‚é€šå‘Š
	- åˆ¤æ–­å†…å®¹ä¸ºå»ºç«‹ç‚¹å¯¹ç‚¹é€šä¿¡
	- æå–è¢«å«å·ç ï¼Œå¸¦å®½
	- é€šè¿‡å·ç  è¯»å–ç›¸åº”é…ç½®
	- åˆ›å»ºç‚¹å¯¹ç‚¹ä¼šè¯è¡¨ï¼Œå¹¶å¡«å…¥zk_ipï¼Œè¢«å«å·ç ï¼Œå¸¦å®½ï¼Œé…ç½®ï¼Œè‡ªåŠ¨åˆ†é… bridge->zk ä¸šåŠ¡ç«¯å£ï¼Œbridge->tmsä¸šåŠ¡ç«¯å£
	- ä¼šè¯è¡¨è§¦å‘tmsä¾§å‘èµ·å‘¼å«
	- é€šè¿‡tcpå‘é€
	- æ¥æ”¶tcpå“åº”ï¼Œæ›´æ–°ä¼šè¯è¡¨çŠ¶æ€
	- ä¼šè¯è¡¨æ£€æµ‹åˆ°ä¹‹å
	- è§£æä¸šåŠ¡ç«¯å£ï¼Œæ›´æ–°åˆ°ä¼šè¯è¡¨ä¸­
    - 

å®ä½“2å‘é€é€šå‘Šæ‹†é“¾Â Â 


è§£ææ‹†é“¾æ¶ˆæ¯Â Â 

  

æå–ç›®çš„ç»ˆç«¯,é€šè¿‡ç›®çš„ç»ˆç«¯å’Œç«™æ§idæ¥æŸ¥æ‰¾ä¼šè¯Â Â 

  

æ›´æ–°ä¼šè¯çŠ¶æ€ä¸ºæ­£åœ¨å…³é—­Â Â 

  

é€šè¿‡sessionæ•°æ®ç»“æ„ è®¿é—®å…¶ä¸­çš„cuå·æ¥å‘tmså‘é€å‘¼å«æŒ‚æ–­Â Â 

  

Â·æ”¶åˆ°å‘¼å«æŒ‚æ–­å“åº”Â Â 

  

Â·é€šè¿‡cuå·æ¥æŸ¥æ‰¾sessionç»“æ„ä½“å¹¶æ›´æ–°å…¶ä¸­çš„çŠ¶æ€Â Â 

  

æ›´æ–°sessionæ•°æ®ç»“æ„ä¸­çš„çŠ¶æ€Â Â 

  

å›æ”¶brdige->tmsä¸šåŠ¡udpç«¯å£åŠsocketï¼Œå›æ”¶brdige->zkudpç«¯å£å’ŒsocketÂ Â 

  

æ›´æ–°sessionä¸­çŠ¶æ€ä¸ºå·²ç»æ‹†é“¾Â Â 

  

é‡Šæ”¾sessionæ•°æ®ç»“æ„ è¯·ä½ è®¾è®¡ä¸€ä¸ªæ¶æ„ æˆ‘å†…å¿ƒå·²ç»æœ‰ä¸€ä¸ªæ¶æ„äº† æˆ‘æƒ³å’Œä½ æ¯”ä¸€ä¸‹è°è®¾è®¡çš„æ›´å¥½

#### ç»“æ„è®¾è®¡ï¼š
- zk_interface: è´Ÿè´£zkåè®®çš„æ•°æ®ç»“æ„å®ç°ï¼Œä»¥åŠè¿™äº›æ•°æ®ç»“æ„çš„æ–¹æ³•ï¼Œåˆ›å»ºæ–¹æ³•å’Œè§£ææ–¹æ³•



ubuntu16.04 è™šæ‹Ÿæœºé•œåƒ å¯†ç  1234



FROM ubuntu:20.04

# é¿å…äº¤äº’å¼å®‰è£…

ENV DEBIAN_FRONTEND=noninteractive

# å®‰è£…å¼€å‘å·¥å…·

RUN apt-get update && apt-get install -y \

build-essential \

cmake \

gdb \

git \

curl \

wget \

vim \

nano \

pkg-config \

valgrind \

&& rm -rf /var/lib/apt/lists/*

# åˆ›å»ºå¼€å‘ç”¨æˆ·

RUN useradd -m -s /bin/bash developer && \

usermod -aG sudo developer && \

echo 'developer:developer' | chpasswd && \

echo 'developer ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers

# è®¾ç½®å·¥ä½œç›®å½•

WORKDIR /workspace

# åˆ‡æ¢åˆ°å¼€å‘ç”¨æˆ·

USER developer

# è®¾ç½®ç¼–è¯‘ç¯å¢ƒå˜é‡ï¼ˆå…¼å®¹æ€§ä¼˜å…ˆï¼‰

ENV CXXFLAGS="-std=c++11"

ENV CC=gcc

ENV CXX=g++

è¿™æ˜¯æˆ‘çš„docker fileæ–‡ä»¶ æ¯æ¬¡æˆ‘è¿›å»è¿™ä¸ªå·¥ç¨‹ éƒ½æç¤ºæˆ‘è¦å®‰è£… æ’ä»¶ ä½†æ˜¯å®‰è£…å®Œä»¥å å½“æˆ‘è¿æ¥è¿™äº›å®¹å™¨ æ—¶ åˆæç¤ºæˆ‘ osç‰ˆæœ¬å¤ªè€äº† ä½†æ˜¯æˆ‘è§‰å¾— ä¸å¤ªå¯¹ï¼Œå› ä¸ºæˆ‘çš„é•œåƒæ˜¯20.04çš„ä¸å¯èƒ½æ˜¯è¿™ä¸ªåŸå›  æˆ‘çš„ç†è§£å°±æ˜¯è¿æ¥æ—¶ è¿æ¥åˆ°äº†é”™è¯¯çš„å®¹å™¨ ä¸Š ä½†æ˜¯å¥½åƒå·¥ç¨‹ä¸‹çš„æœ‰ä¸¤ä¸ªé…ç½®æ–‡ä»¶ ä¸€ä¸ªdevcontainer.json ä¸€ä¸ªdockerfile æˆ‘ç°åœ¨éœ€è¦å¼„æ¸…æ¥šä¸€äº›åŸºæœ¬çš„æ¦‚å¿µ ï¼Œ ä½ æ¥å‘Šè¯‰æˆ‘è¿™ä¸¤ä¸ªé…ç½®æ–‡ä»¶ æ˜¯å¹²å˜›ç”¨çš„ ï¼Œè°¢è°¢Â 

è€Œä¸”ç”±äºæˆ‘æƒ³åœ¨è¿™ä¸ªdockeré‡Œä½¿ç”¨äº¤å‰ç¼–è¯‘






Okay, here's a structural design document for your C++ "Bridge" application, incorporating our discussions on I/O multiplexing, event-driven architecture, and multithreading. I'll also address your question about using JSON, spdlog, and Redis.

Yes, you absolutely **should consider using libraries like a JSON parser, spdlog, and Redis**, especially given your requirements:

- **JSON Library (e.g., nlohmann/json, RapidJSON):** Excellent for reading configuration files if they are in JSON format. This simplifies configuration management significantly.
- **spdlog:** A very good choice for high-performance, flexible, and structured logging in C++. Logging is crucial for debugging and monitoring any server application.
- **Redis:** Forä¸»å¤‡å®¹ç¾ (active-standby disaster recovery), Redis is a strong candidate. It can be used to store and replicate active session state. If a primary Bridge instance fails, a standby instance can potentially take over by loading session information from Redis, allowing for more seamless failover or graceful termination of existing calls.

---

## Bridge ç³»ç»Ÿç»“æ„è®¾è®¡è¯´æ˜æ–‡æ¡£

æœ¬æ–‡æ¡£æè¿°äº† Bridge ç³»ç»Ÿçš„ç»“æ„è®¾è®¡ï¼Œè¯¥ç³»ç»Ÿä½œä¸º ZK å®ä½“å’Œ TMS ç³»ç»Ÿä¹‹é—´çš„ä¸­é—´æ¡¥æ¢ï¼Œæ”¯æŒä¿¡ä»¤å’Œåª’ä½“ä¸šåŠ¡çš„è½¬å‘ã€‚è®¾è®¡è€ƒè™‘äº†é«˜æ€§èƒ½ã€é«˜å¹¶å‘ã€å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§ï¼Œé‡‡ç”¨äº†I/Oå¤ç”¨ã€äº‹ä»¶é©±åŠ¨å’Œå¤šçº¿ç¨‹çš„æ¶æ„ã€‚

---

### 1. æ ¸å¿ƒè®¾è®¡åŸåˆ™ ğŸŒŸ

- **æ¨¡å—åŒ–:** ç³»ç»Ÿåˆ’åˆ†ä¸ºå…·æœ‰æ˜ç¡®èŒè´£çš„ç‹¬ç«‹æ¨¡å—ã€‚
- **å¼‚æ­¥éé˜»å¡:** I/Oæ“ä½œå’Œæ ¸å¿ƒé€»è¾‘é‡‡ç”¨å¼‚æ­¥éé˜»å¡æ¨¡å¼ï¼Œä»¥æé«˜å¹¶å‘å¤„ç†èƒ½åŠ›ã€‚
- **äº‹ä»¶é©±åŠ¨:** ç³»ç»Ÿç”±å¤–éƒ¨äº‹ä»¶ï¼ˆå¦‚ç½‘ç»œæ¶ˆæ¯ã€å®šæ—¶å™¨ï¼‰å’Œå†…éƒ¨äº‹ä»¶ï¼ˆä»»åŠ¡å®Œæˆï¼‰é©±åŠ¨ã€‚
- **çº¿ç¨‹åˆ†ç¦»:** I/Oå¯†é›†å‹ä»»åŠ¡ä¸CPUå¯†é›†å‹ï¼ˆæˆ–ä¸šåŠ¡é€»è¾‘ï¼‰ä»»åŠ¡ç”±ä¸åŒç±»å‹çš„çº¿ç¨‹å¤„ç†ã€‚
- **ä¼šè¯ä¸­å¿ƒåŒ–:** `Session` å¯¹è±¡å°è£…äº†å•ä¸ªç«¯åˆ°ç«¯å‘¼å«çš„æ ¸å¿ƒçŠ¶æ€å’Œé€»è¾‘ã€‚
- **çº¿ç¨‹å®‰å…¨:** æ‰€æœ‰å…±äº«èµ„æºï¼ˆä¼šè¯è¡¨ã€ç«¯å£æ± ã€åª’ä½“è½¬å‘è¡¨ç­‰ï¼‰çš„è®¾è®¡éƒ½å¿…é¡»è€ƒè™‘çº¿ç¨‹å®‰å…¨ã€‚

---

### 2. æ€»ä½“æ¶æ„å›¾ (æ¦‚å¿µ)

```
+---------------------+      +-----------------------+      +---------------------+
|     ZK Entities     |<---->|      ZK Interface     |<---->|                     |
| (10 ZKs, 1 port ea. |      | (10 Listeners,        |      |                     |
|  Signaling & Media) |      |  Demux, Proto Handler) |      |   Coordinator /   |
+---------------------+      +-----------+-----------+      |   Event Router    |      +-------------------+
                                         ^                          |                     |----->|  Session Module   |
                                         |                          v                     |<-----| (SessionManager,  |
                                         | (Tasks)           +------+------+              |      |  Session Objects) |
                                         |                   | Task Queue  |              |      +-------------------+
                                         v                   +------+------+              |                |
+---------------------+      +-----------+-----------+              | (Tasks)            |                | (Config MediaRelay)
|     TMS System      |<---->|     TMS Interface     |<-------------+                     |                v
| (1 TCP Sig, N UDP   |      | (TCP Conn, N UDP Listen,|             v                     |      +-------------------+
|  Media from TMS)    |      |  Proto Handler)       |      +-----------------------+      |----->| MediaRelay Module |
+---------------------+      +-----------------------+      |   Worker Thread Pool  |------      |(Fast Fwd Table,   |
                                                            +-----------------------+             | Header Manip.)    |
                                                                                                  +-------------------+
                                                                     |  ^
                                                                     |  | (Alloc/Release)
                                                                     v  |
+-----------------------+     +-----------------------+     +-----------------------+
| Communication Layer   |<--->|    Protocol Layer     |<--->|    Port Manager       |
| (Async Sockets)       |     | (ZK/TMS Parsers/Fmts) |     | (UDP Port Pool)       |
+-----------------------+     +-----------------------+     +-----------------------+

+-----------------------+     +-----------------------+
| Configuration Manager |     |     Logging (spdlog)  |
| (JSON for config)     |     +-----------------------+
+-----------------------+

+-----------------------+
| Redis (Optional for HA|
| Session State Sync)   |
+-----------------------+
```

---

### 3. çº¿ç¨‹æ¨¡å‹ ğŸ§µ

- **I/O çº¿ç¨‹ (å°‘é‡, e.g., `num_cores / 2` æˆ– `num_cores`):**
    - è¿è¡Œ `epoll` (æˆ–ç­‰æ•ˆçš„) äº‹ä»¶å¾ªç¯ã€‚
    - è´Ÿè´£æ‰€æœ‰Socketçš„éé˜»å¡è¯»å†™ã€‚
    - è¿›è¡Œæœ€åŸºæœ¬çš„æ•°æ®åŒ…è§£æï¼ˆå¦‚è¯†åˆ«æ¥æºã€åˆ¤æ–­æ˜¯ä¿¡ä»¤è¿˜æ˜¯åª’ä½“ï¼Œæå–ä¼šè¯æ ‡è¯†ç¬¦ï¼‰ã€‚
    - å°†è§£æåçš„ä»»åŠ¡ï¼ˆå°è£…äº†æ•°æ®å’Œä¸Šä¸‹æ–‡ï¼‰æ”¾å…¥ä»»åŠ¡é˜Ÿåˆ—ï¼Œäº¤ç”±å·¥ä½œçº¿ç¨‹æ± å¤„ç†ã€‚
    - ç›´æ¥å¤„ç†æä½å»¶è¿Ÿçš„åª’ä½“è½¬å‘ï¼ˆå¦‚æœåŒ…å¤´æ“ä½œç®€å•ï¼‰ã€‚
- **å·¥ä½œçº¿ç¨‹æ±  (å›ºå®šæ•°é‡, e.g., `num_cores` æˆ–æ›´å¤š):**
    - ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡ã€‚
    - æ‰§è¡Œæ‰€æœ‰æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼š`Session` å¯¹è±¡çš„åˆ›å»ºã€çŠ¶æ€æ›´æ–°ã€å†³ç­–ï¼›ä¸ `ConfigManager`ã€`PortManager` äº¤äº’ï¼›å‡†å¤‡ä¿¡ä»¤æ•°æ®ï¼›é€šè¿‡ `Coordinator` æŒ‡ç¤ºæ¥å£å±‚å‘é€æ¶ˆæ¯ï¼›é…ç½® `MediaRelay`ã€‚
- **å¯é€‰çš„ä¸“ç”¨çº¿ç¨‹ï¼š**
    - TMSå¿ƒè·³çº¿ç¨‹ã€‚
    - å®šæ—¶æ¸…ç†çº¿ç¨‹ (å¦‚æ¸…ç†è¿‡æœŸä¼šè¯)ã€‚

---

### 4. ä»£ç ç»“æ„ä¸æ¨¡å—è¯´æ˜

```
bridge_system/
â”œâ”€â”€ main.cpp                     # ç¨‹åºå…¥å£, åˆå§‹åŒ–å„æ¨¡å—, å¯åŠ¨I/Oäº‹ä»¶å¾ªç¯å’Œå·¥ä½œçº¿ç¨‹æ± 
â”‚
â”œâ”€â”€ common/                      # é€šç”¨åŸºç¡€æ¨¡å—
â”‚   â”œâ”€â”€ communication/           # åº•å±‚å¼‚æ­¥ç½‘ç»œé€šä¿¡å°è£…
â”‚   â”‚   â”œâ”€â”€ async_udp_socket.{h,cpp}
â”‚   â”‚   â””â”€â”€ async_tcp_client.{h,cpp} # (å¦‚æœTMSä¿¡ä»¤æ˜¯Clientæ¨¡å¼)
â”‚   â”‚   â””â”€â”€ async_tcp_server.{h,cpp} # (å¦‚æœTMSä¿¡ä»¤æ˜¯Serveræ¨¡å¼æˆ–ç®¡ç†æ¥å£)
â”‚   â”œâ”€â”€ task_queue/              # çº¿ç¨‹å®‰å…¨çš„ä»»åŠ¡é˜Ÿåˆ— (I/Oçº¿ç¨‹ä¸å·¥ä½œçº¿ç¨‹äº¤äº’)
â”‚   â”‚   â””â”€â”€ concurrent_queue.h
â”‚   â””â”€â”€ utils/                   # å…¶ä»–å·¥å…·ç±» (e.g., string manipulation, timers)
â”‚       â””â”€â”€ ...
â”‚
â”œâ”€â”€ protocols/                   # åè®®å®šä¹‰ä¸ç¼–è§£ç  (æ— çŠ¶æ€å·¥å…·åº“)
â”‚   â”œâ”€â”€ zk_protocol/
â”‚   â”‚   â”œâ”€â”€ zk_message_types.h   # ZKåè®®æ¶ˆæ¯çš„C++ç»“æ„ä½“å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ zk_parser.{h,cpp}    # è§£æZKå­—èŠ‚æµ -> ç»“æ„ä½“
â”‚   â”‚   â””â”€â”€ zk_formatter.{h,cpp} # ç»“æ„ä½“ -> ZKå­—èŠ‚æµ
â”‚   â””â”€â”€ tms_protocol/
â”‚       â”œâ”€â”€ tms_message_types.h
â”‚       â”œâ”€â”€ tms_parser.{h,cpp}
â”‚       â””â”€â”€ tms_formatter.{h,cpp}
â”‚
â”œâ”€â”€ interfaces/                  # å¤–éƒ¨ç³»ç»Ÿæ¥å£é€‚é…å±‚
â”‚   â”œâ”€â”€ zk_interface/
â”‚   â”‚   â”œâ”€â”€ zk_listener.{h,cpp}  # ç®¡ç†10ä¸ªUDPç›‘å¬Socket (æ¥æ”¶ZKä¿¡ä»¤å’Œåª’ä½“)
â”‚   â”‚   â”‚                        # åŠŸèƒ½: ä½¿ç”¨communicationå±‚, æ³¨å†Œåˆ°epoll, è¯»å–æ•°æ®,
â”‚   â”‚   â”‚                        #       åˆæ­¥è§£æ(è¯†åˆ«ZK ID, ä¼šè¯ID, ä¿¡ä»¤/åª’ä½“),
â”‚   â”‚   â”‚                        #       åˆ›å»ºä»»åŠ¡å¹¶æ”¾å…¥TaskQueueæˆ–ç›´æ¥è°ƒç”¨MediaRelay
â”‚   â”‚   â”œâ”€â”€ zk_sender.{h,cpp}    # å°è£…å‘ZKå‘é€æ•°æ® (ä½¿ç”¨communicationå±‚å’Œzk_formatter)
â”‚   â”‚   â””â”€â”€ zk_defs.h            # ZKæ¥å£ç›¸å…³çš„å†…éƒ¨å¸¸é‡/å®šä¹‰
â”‚   â””â”€â”€ tms_interface/
â”‚       â”œâ”€â”€ tms_connector.{h,cpp}# ç®¡ç†ä¸TMSçš„TCPä¿¡ä»¤è¿æ¥ (å¿ƒè·³, æ”¶å‘)
â”‚       â”œâ”€â”€ tms_media_listener.{h,cpp} # ç®¡ç†Nä¸ªUDPç›‘å¬Socket (æ¥æ”¶TMSåª’ä½“)
â”‚       â”œâ”€â”€ tms_sender.{h,cpp}   # å°è£…å‘TMSå‘é€æ•°æ®
â”‚       â””â”€â”€ tms_defs.h
â”‚
â”œâ”€â”€ core_logic/                  # æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ coordinator.{h,cpp}      # åè°ƒå™¨/è·¯ç”±å™¨: åœ¨æ¥å£å±‚å’Œä¼šè¯æ¨¡å—é—´ä¼ é€’äº‹ä»¶å’ŒæŒ‡ä»¤
â”‚   â”‚                            # åŠŸèƒ½: ç”±å·¥ä½œçº¿ç¨‹è°ƒç”¨, è·¯ç”±åˆ°SessionManageræˆ–å…·ä½“Session
â”‚   â”œâ”€â”€ session.h                # Sessionå¯¹è±¡å®šä¹‰
â”‚   â”‚   â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: SessionState (enum), ZK/TMSåª’ä½“ä¿¡æ¯,
â”‚   â”‚   â”‚                        #               ä¼šè¯ID, target_id, å¸¦å®½, Cué…ç½®å¼•ç”¨ç­‰
â”‚   â”‚   â”‚                        # ä¸»è¦å‡½æ•°: handleZkEvent(), handleTmsEvent(),
â”‚   â”‚   â”‚                        #           processMedia(), setupMediaRelayRules(),
â”‚   â”‚   â”‚                        #           initiateTmsCall(), sendStateToZk(), cleanup()
â”‚   â”œâ”€â”€ session.cpp              # Sessionå¯¹è±¡å®ç° (çŠ¶æ€æœº, æ ¸å¿ƒä¸šåŠ¡æµç¨‹)
â”‚   â”œâ”€â”€ session_manager.h        # SessionManagerç±»å®šä¹‰ (çº¿ç¨‹å®‰å…¨)
â”‚   â”‚   â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: std::unordered_map<SessionID, std::shared_ptr<Session>> active_sessions;
â”‚   â”‚   â”‚                        #               (å¯èƒ½è¿˜æœ‰å…¶ä»–ç´¢å¼•map, å¦‚ Port -> SessionID)
â”‚   â”‚   â”‚                        # ä¸»è¦å‡½æ•°: createSession(), findSession(), removeSession()
â”‚   â”œâ”€â”€ session_manager.cpp      # SessionManagerå®ç°
â”‚   â”œâ”€â”€ port_manager.h           # PortManagerç±»å®šä¹‰ (çº¿ç¨‹å®‰å…¨)
â”‚   â”‚   â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: std::set<uint16_t> available_ports; std::mutex mtx;
â”‚   â”‚   â”‚                        # ä¸»è¦å‡½æ•°: allocatePort(), releasePort()
â”‚   â”œâ”€â”€ port_manager.cpp         # PortManagerå®ç°
â”‚   â””â”€â”€ config_manager.h         # ConfigManagerç±»å®šä¹‰
â”‚       â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: Structs for ZK/TMS config, CU config table,
â”‚       â”‚                        #               CU-target_id map. (ä½¿ç”¨JSONåº“è§£æ)
â”‚       â”‚                        # ä¸»è¦å‡½æ•°: loadConfigs(), getZkConfig(zkId), getTmsConfig(),
â”‚       â”‚                        #           getCuConfig(cuId), getTargetCuMapping(targetId)
â”‚   â””â”€â”€ config_manager.cpp       # ConfigManagerå®ç°
â”‚
â”œâ”€â”€ media_processing/            # åª’ä½“å¤„ç†ä¸è½¬å‘
â”‚   â””â”€â”€ media_relay.{h,cpp}      # åª’ä½“ä¸­ç»§æ¨¡å— (çº¿ç¨‹å®‰å…¨)
â”‚       â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: ForwardingRule (åŒ…å«ç›®æ ‡IP/Port, åŒ…å¤´å¤„ç†å‡½æ•°æŒ‡é’ˆ/lambda, å‘é€Socketå¼•ç”¨)
â”‚       â”‚                        #               std::unordered_map<uint16_t /*local_rcv_port*/, ForwardingRule> zk_to_tms_flows;
â”‚       â”‚                        #               std::unordered_map<uint16_t /*local_rcv_port*/, ForwardingRule> tms_to_zk_flows;
â”‚       â”‚                        # ä¸»è¦å‡½æ•°: setupFlow(), teardownFlow(),
â”‚       â”‚                        #           processIncomingZkMedia(packet, local_port_or_session_id),
â”‚       â”‚                        #           processIncomingTmsMedia(packet, local_port)
â”‚
â””â”€â”€ logging/                     # æ—¥å¿—æ¨¡å—
    â””â”€â”€ logger_wrapper.{h,cpp}   # spdlogçš„å°è£…å’Œå…¨å±€è®¿é—®ç‚¹
```

---

### 5. å…³é”®æ•°æ®ç»“æ„ä¸å‡½æ•°æ¦‚è¿° (éƒ¨åˆ†å·²åœ¨ä¸Šé¢æåŠ)

- **`Session` å¯¹è±¡:**
    - **æ•°æ®:** `sessionId`, `zkId`, `targetId`, `bandwidth`, `zkAllocatedBridgeMediaPort` (ç”¨äºå‘å¾€ZK), `tmsAllocatedBridgeMediaPort` (ç”¨äºæ”¶å‘TMSåª’ä½“), `tmsRemoteMediaEndpoint`, `cuConfig`, `currentState (enum: IDLE, ZK_INITIATED, TMS_CONNECTING, ACTIVE, TERMINATING, ...)`ã€‚
    - **å‡½æ•°:** `handleZkSignaling(parsedMsg)`, `handleTmsSignaling(parsedMsg)`, `allocateMediaPorts()`, `setupMediaRelay()`, `sendToZkViaCoordinator(msg)`, `sendToTmsViaCoordinator(msg)`, `terminate()`.
- **`SessionManager`:**
    - **æ•°æ®:** `std::unordered_map<std::string /*SessionID*/, std::shared_ptr<Session>> sessions_by_id;` (ä¸»è¡¨ï¼Œçº¿ç¨‹å®‰å…¨), å¯èƒ½è¿˜æœ‰å…¶ä»–è¾…åŠ©ç´¢å¼•è¡¨å¦‚ `std::unordered_map<uint16_t /*BridgeLocalMediaPort*/, std::string /*SessionID*/> port_to_session_map;` (ç”¨äºåª’ä½“åŒ…åˆæ¬¡å…³è”ï¼Œä½†åç»­åª’ä½“è½¬å‘ä¸ä¾èµ–å®ƒ)ã€‚
    - **å‡½æ•°:** `createSessionFromZk(zkData)`, `getSessionById(id)`, `getSessionByLocalMediaPort(port)`, `removeSession(id)`.
- **`MediaRelay`:**
    - **æ•°æ®:** å¦‚ä¸Šæ‰€è¿°çš„ `active_flows_table` (ä¸¤ä¸ªæ–¹å‘çš„è½¬å‘è¡¨)ï¼Œé”®ä¸º Bridge æœ¬åœ°æ¥æ”¶åª’ä½“çš„ç«¯å£ï¼Œå€¼ä¸ºåŒ…å«å®Œæ•´è½¬å‘è·¯å¾„å’Œå¤„ç†è§„åˆ™çš„ç»“æ„ä½“ã€‚**è¿™äº›è¡¨å¿…é¡»æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚**
    - **å‡½æ•°:** `addFlow(sessionId, zkLocalPort, zkRemoteEp, tmsLocalPort, tmsRemoteEp, zkToTmsHeaderProc, tmsToZkHeaderProc)`, `removeFlow(sessionId_or_ports)`, `onUdpPacketReceived(buffer, len, localRecvPort, remoteSenderEp)`.
- **`ZkListener` (in `zk_interface`):**
    - **æ•°æ®:** `std::vector<std::unique_ptr<AsyncUDPSocket>> zk_listening_sockets;` (10ä¸ªï¼Œæ¯ä¸ªå¯¹åº”ä¸€ä¸ªZKçš„ä¿¡ä»¤/åª’ä½“å…¥å£)ã€‚
    - **å‡½æ•°:** `startListening()`, `onDataReceived(socket_idx, data, remote_ep)` (å›è°ƒï¼Œç”±æ­¤åˆ›å»ºä»»åŠ¡äº¤å·¥ä½œçº¿ç¨‹æ± )ã€‚

---

### 6. åº“çš„ä½¿ç”¨å»ºè®®

- **JSON åº“ (å¦‚ nlohmann/json for Modern C++):**
    - **ç”¨é€”:** åœ¨ `ConfigManager` ä¸­ç”¨äºè§£æ `.json` æ ¼å¼çš„é…ç½®æ–‡ä»¶ï¼ˆcué…ç½®è¡¨, cuå’Œtarget_idæ˜ å°„è¡¨, tms/zk ip portç­‰ï¼‰ã€‚
    - **é›†æˆ:** `ConfigManager` ä¾èµ–æ­¤åº“ã€‚
- **spdlog:**
    - **ç”¨é€”:** åœ¨æ•´ä¸ªåº”ç”¨ç¨‹åºä¸­æä¾›é«˜æ€§èƒ½çš„ã€å¯é…ç½®çš„æ—¥å¿—è®°å½•ã€‚
    - **é›†æˆ:** åˆ›å»ºä¸€ä¸ªå…¨å±€å¯è®¿é—®çš„ `LoggerWrapper` æˆ–ç›´æ¥åœ¨å„æ¨¡å—ä¸­ä½¿ç”¨ `spdlog` å®ä¾‹ã€‚æ—¥å¿—çº§åˆ«åº”å¯é…ç½®ã€‚
- **Redis (ç”¨äºä¸»å¤‡å®¹ç¾ - å¯é€‰çš„å¢å¼ºåŠŸèƒ½):**
    - **ç”¨é€”:**
        1. **ä¼šè¯çŠ¶æ€åŒæ­¥/æŒä¹…åŒ–:** å½“ `Session` å¯¹è±¡çš„çŠ¶æ€å‘ç”Ÿå…³é”®å˜åŒ–ï¼ˆåˆ›å»ºã€æ¿€æ´»ã€åª’ä½“ä¿¡æ¯æ›´æ–°ã€æ‹†é™¤ï¼‰æ—¶ï¼Œå¯ä»¥å°†è¿™äº›çŠ¶æ€å¼‚æ­¥åœ°å†™å…¥ Redisã€‚
        2. **ä¸»å¤‡åˆ‡æ¢:** å¦‚æœä¸» Bridge å®ä¾‹æ•…éšœï¼Œå¤‡ç”¨ Bridge å®ä¾‹å¯åŠ¨åå¯ä»¥ä» Redis è¯»å–æ´»åŠ¨çš„ä¼šè¯ä¿¡æ¯ï¼Œå°è¯•æ¢å¤ä¼šè¯ï¼ˆä¾‹å¦‚ï¼Œé‡æ–°å»ºç«‹åª’ä½“è·¯å¾„ï¼Œæˆ–è‡³å°‘çŸ¥é“å“ªäº›ä¼šè¯å­˜åœ¨è¿‡ä»¥ä¾¿è¿›è¡Œæ¸…ç†æˆ–é€šçŸ¥ï¼‰ã€‚
        3. **åˆ†å¸ƒå¼é”/é¢†å¯¼è€…é€‰ä¸¾ (å¯é€‰):** å¦‚æœæœ‰å¤šä¸ªActiveçš„Bridgeå®ä¾‹ï¼ˆæ›´å¤æ‚çš„è´Ÿè½½å‡è¡¡åœºæ™¯ï¼‰ï¼Œæˆ–è€…ä¸¥æ ¼çš„ä¸»å¤‡åˆ‡æ¢ï¼Œå¯èƒ½éœ€è¦ã€‚
        4. **(å¯é€‰) åˆ†å¸ƒå¼ç«¯å£ç®¡ç†:** å¦‚æœå¤šä¸ªBridgeå®ä¾‹éœ€è¦ä»ä¸€ä¸ªå…¨å±€å”¯ä¸€çš„ç«¯å£æ± ä¸­åˆ†é…ç«¯å£ã€‚
    - **é›†æˆ:**
        - `SessionManager` æˆ– `Session` å¯¹è±¡åœ¨çŠ¶æ€å˜æ›´æ—¶ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªä»»åŠ¡ï¼ˆæˆ–ç›´æ¥è°ƒç”¨ï¼‰ä¸ Redis äº¤äº’çš„æ¨¡å—ã€‚
        - éœ€è¦ä¸€ä¸ª `RedisClient` æˆ– `RedisInterface` æ¨¡å—æ¥å°è£…ä¸ Redis æœåŠ¡å™¨çš„é€šä¿¡ (å¯ä»¥ä½¿ç”¨å¦‚ `redis-plus-plus` æˆ– `hiredis` C/C++ å®¢æˆ·ç«¯åº“)ã€‚
        - **è€ƒè™‘ç‚¹:**
            - å†™å…¥ Redis çš„é¢‘ç‡å’Œæ•°æ®é‡ï¼ˆé¿å…æˆä¸ºç“¶é¢ˆï¼‰ã€‚
            - æ•°æ®ä¸€è‡´æ€§ä¸åºåˆ—åŒ–/ååºåˆ—åŒ–ã€‚
            - Redis çš„éƒ¨ç½²å’Œå¯ç”¨æ€§ã€‚
            - ä¼šè¯æ¢å¤çš„å¤æ‚æ€§ï¼ˆé‡æ–°å»ºç«‹ UDP åª’ä½“æµé€šå¸¸æ¯” TCP è¿æ¥æ¢å¤æ›´å¤æ‚ï¼Œå› ä¸ºUDPæ— çŠ¶æ€ï¼‰ã€‚å¯¹äºåª’ä½“ï¼Œå¯èƒ½æ›´å¤šçš„æ˜¯çŸ¥é“ä¼šè¯å­˜åœ¨ï¼Œç„¶åå°è¯•å¿«é€Ÿæ‹†é™¤æˆ–æŒ‡ç¤ºå¯¹ç«¯é‡å»ºã€‚

---

è¿™ä¸ªç»“æ„è®¾è®¡è€ƒè™‘äº†æ‚¨æœ€æ–°çš„éœ€æ±‚å’Œæˆ‘ä»¬ä¹‹å‰çš„è®¨è®ºï¼Œæ—¨åœ¨æä¾›ä¸€ä¸ªæ¸…æ™°ã€é«˜æ•ˆä¸”å¯æ‰©å±•çš„ C++ Bridge ç³»ç»Ÿè“å›¾ã€‚å®é™…å®ç°æ—¶ï¼Œè¿˜éœ€è¦åœ¨å¼‚æ­¥ç¼–ç¨‹ã€é”™è¯¯å¤„ç†ã€çº¿ç¨‹åŒæ­¥ç»†èŠ‚ä¸Šè¿›è¡Œç»†è‡´çš„å·¥ä½œã€‚




å¥½çš„ï¼Œæˆ‘ä»¬æ¥åŸºäºä¹‹å‰çš„è®¨è®ºï¼Œå¼€å§‹æ•´ç†ä¸€ä»½æ›´è¯¦ç»†çš„è®¾è®¡æ–‡æ¡£ã€‚æˆ‘ä»¬å°†ä»æ‚¨æœ€å…³æ³¨çš„ `protocols/zk_protocol/` æ¨¡å—å¼€å§‹ï¼Œç„¶åé€æ­¥æ‰©å±•åˆ°å…¶ä»–æ¨¡å—ä¸å®ƒäº¤äº’çš„éƒ¨åˆ†ï¼Œä»¥åŠå…¶ä»–æ¨¡å—è‡ªèº«çš„ä¸€äº›å…³é”®è®¾è®¡ç‚¹ã€‚

è¿™ä¸ªè¿‡ç¨‹æˆ‘ä¼šå°½é‡ç»†åŒ–ï¼Œä½†è¯·è®°ä½ï¼ŒçœŸæ­£çš„è¯¦ç»†è®¾è®¡æ˜¯ä¸€ä¸ªéå¸¸ç»†è‡´çš„å·¥ä½œï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¸»è¦æ˜¯æ„å»ºä¸€ä¸ªæ¸…æ™°çš„æ¡†æ¶å’Œå…³é”®è¦ç´ ã€‚

---

## Bridge ç³»ç»Ÿè¯¦ç»†è®¾è®¡ (è‰æ¡ˆ V1)

**æ–‡æ¡£ç›®æ ‡ï¼š** æ˜ç¡®å„æ¨¡å—çš„æ ¸å¿ƒèŒè´£ã€æ¥å£ã€å…³é”®æ•°æ®ç»“æ„å’Œäº¤äº’æ–¹å¼ï¼Œä¸ºåç»­ç¼–ç å®ç°æä¾›æŒ‡å¯¼ã€‚æœ¬è®¾è®¡åŸºäºI/Oå¤ç”¨ã€äº‹ä»¶é©±åŠ¨å’Œå¤šçº¿ç¨‹ï¼ˆI/Oçº¿ç¨‹ + å·¥ä½œçº¿ç¨‹æ± ï¼‰çš„æ¶æ„æ¨¡å‹ã€‚

---

### **ç¬¬ä¸€éƒ¨åˆ†ï¼šåè®®å±‚ (Protocol Layer)**

#### **æ¨¡å— 1.1: `protocols/zk_protocol/` - ZK åè®®å¤„ç†æ¨¡å—**

1. æ¦‚è¿° (Overview):

å®šä¹‰Bridgeä¸ZKå®ä½“é—´é€šä¿¡åè®®çš„æ¶ˆæ¯æ•°æ®ç»“æ„ï¼Œå¹¶æä¾›å°†åŸå§‹å­—èŠ‚æµä¸è¿™äº›ç»“æ„ä½“ç›¸äº’è½¬æ¢ï¼ˆç¼–ç /è§£ç ï¼‰çš„çº¯åŠŸèƒ½æ€§æ–¹æ³•ã€‚æœ¬æ¨¡å—ä¸å¤„ç†ç½‘ç»œI/Oï¼Œä¹Ÿä¸åŒ…å«UDPä¹‹ä¸Šçš„è‡ªå®šä¹‰å¯é ä¼ è¾“é€»è¾‘ï¼ˆå¦‚é‡ä¼ ã€ACKçŠ¶æ€ç®¡ç†ï¼‰ã€‚

**2. ä¸»è¦èŒè´£ (Key Responsibilities):**

- å®šä¹‰æ‰€æœ‰ZKä¸Šä¸‹è¡Œåè®®æ¶ˆæ¯çš„C++æ•°æ®ç»“æ„/ç±»ï¼ŒåŒ…æ‹¬å…¬å…±å¤´éƒ¨å’Œç‰¹å®šæ¶ˆæ¯çš„è½½è·ã€‚
- æä¾›è§£ç ï¼ˆè§£æï¼‰åŠŸèƒ½ï¼šå°†æ¥æ”¶åˆ°çš„åŸå§‹ZK UDPæ•°æ®åŒ…å­—èŠ‚æµï¼Œæ ¹æ®å…¬å…±å¤´éƒ¨ä¸­çš„ç‰¹å®šå­—æ®µï¼ˆå¦‚æ¶ˆæ¯ç±»å‹ã€ä¿¡æ¯å•å…ƒç±»å‹ï¼‰è¯†åˆ«æ¶ˆæ¯ï¼Œå¹¶è½¬æ¢ä¸ºå¯¹åº”çš„C++æ¶ˆæ¯ç»“æ„ä½“ã€‚æ”¯æŒè§£æåŒ…å«å¤šä¸ªâ€œä¿¡æ¯å•å…ƒâ€çš„å¤åˆæ¶ˆæ¯ã€‚
- æä¾›ç¼–ç ï¼ˆæ ¼å¼åŒ–ï¼‰åŠŸèƒ½ï¼šå°†å†…éƒ¨C++æ¶ˆæ¯ç»“æ„ä½“åºåˆ—åŒ–ä¸ºå¾…å‘é€çš„UDPå­—èŠ‚æµã€‚
- å¤„ç†åè®®å­—æ®µçš„å­—èŠ‚åºè½¬æ¢ï¼ˆç½‘ç»œå­—èŠ‚åº &lt;-> ä¸»æœºå­—èŠ‚åºï¼‰ã€‚

**3. ä¸»è¦è¾“å…¥ (Key Inputs to its functions):**

- è§£ç å‡½æ•°è¾“å…¥: `const unsigned char* buffer`, `size_t length` (åŸå§‹å­—èŠ‚æµåŠå…¶é•¿åº¦)ã€‚
- ç¼–ç å‡½æ•°è¾“å…¥: `const SpecificZkMessage& message_struct` (å¾…ç¼–ç çš„C++æ¶ˆæ¯ç»“æ„ä½“å¯¹è±¡)ã€‚

**4. ä¸»è¦è¾“å‡º (Key Outputs from its functions):**

- è§£ç å‡½æ•°è¾“å‡º: `std::optional<ParsedZkMessageVariant>` (åŒ…å«è§£æåçš„C++æ¶ˆæ¯ç»“æ„ä½“ï¼Œæˆ–åœ¨å¤±è´¥æ—¶ä¸ºç©º) æˆ–åŒ…å«é”™è¯¯ç çš„ç‰¹å®šç»“æœç±»å‹ã€‚
- ç¼–ç å‡½æ•°è¾“å‡º: `std::vector<unsigned char>` (åŒ…å«åºåˆ—åŒ–åçš„å­—èŠ‚æµ) æˆ–é”™è¯¯ç ã€‚

**5. ä¾èµ–çš„å…¶ä»–æ¨¡å— (Dependencies):**

- C++æ ‡å‡†åº“ (å¦‚ `<vector>`, `<string>`, `<cstdint>`, `<variant>`, `<optional>`, `<algorithm>`)ã€‚
- å­—èŠ‚åºè½¬æ¢å‡½æ•° (å¦‚ç³»ç»Ÿæä¾›çš„ `htons`, `ntohl` ç­‰ï¼Œé€šå¸¸åœ¨ `<arpa/inet.h>` æˆ–ç”± `common/utils/endian_converter.h` å°è£…)ã€‚

**6. è¢«å“ªäº›æ¨¡å—ä¾èµ– (Depended On By):**

- `interfaces/zk_interface/` (ä¸»è¦ä½¿ç”¨è€…ï¼Œè°ƒç”¨æœ¬æ¨¡å—çš„ç¼–è§£ç å‡½æ•°)ã€‚

**7. æ ¸å¿ƒå¯¹å¤–æ¥å£ (Key Public APIs - åˆæ­¥è®¾æƒ³):**

- **`zk_message_types.h`**:
    
    C++
    
    ```
    #include <cstdint>
    #include <string>
    #include <vector>
    #include <variant>
    #include <optional>
    
    namespace ZkProtocol {
    
    // --- æšä¸¾å®šä¹‰ ---
    enum class MessageType : uint16_t { // å‡è®¾åœ¨å…¬å…±å¤´éƒ¨ä¸­å®šä¹‰
        INITIATE_CALL_REQUEST = 0x0001,
        INITIATE_CALL_RESPONSE = 0x0002,
        CALL_DISCONNECT_REQUEST = 0x0003,
        CALL_DISCONNECT_RESPONSE = 0x0004,
        HEARTBEAT_REQUEST = 0x0005,
        HEARTBEAT_RESPONSE = 0x0006,
        MEDIA_DATA_FORWARD = 0x0100, // ç”¨äºåª’ä½“æ•°æ®åŒ…ï¼Œç”±MediaRelayè°ƒç”¨
        // ... å…¶ä»–ä¿¡ä»¤æ¶ˆæ¯ç±»å‹
        UNKNOWN = 0xFFFF
    };
    
    enum class ReliabilityFlags : uint8_t {
        NONE = 0x00,
        ACK_REQUESTED = 0x01,
        IS_ACK = 0x02,
        // ... å…¶ä»–å¯é æ€§ç›¸å…³çš„æ ‡å¿—
    };
    
    // --- å…¬å…±æ¶ˆæ¯å¤´ ---
    struct CommonHeader {
        uint32_t sequence_number;    // åºåˆ—å· (ç”¨äºå¯é æ€§å±‚)
        uint32_t ack_number;         // ç¡®è®¤å· (ç”¨äºå¯é æ€§å±‚)
        ReliabilityFlags flags;       // æ ‡å¿—ä½ (ç”¨äºå¯é æ€§å±‚)
        MessageType message_type;    // æ¶ˆæ¯ç±»å‹ (ç”¨äºåˆ†å‘åˆ°å…·ä½“æ¶ˆæ¯è§£æ)
        uint16_t total_length;       // æ•´ä¸ªæ¶ˆæ¯çš„æ€»é•¿åº¦ (åŒ…æ‹¬å¤´éƒ¨å’Œè½½è·)
        // ... å…¶ä»–é€šç”¨å¤´éƒ¨å­—æ®µï¼Œå¦‚ç‰ˆæœ¬å·ï¼Œæº/ç›®æ ‡å®ä½“IDï¼ˆå¦‚æœåè®®æœ‰è§„å®šï¼‰
    };
    constexpr size_t COMMON_HEADER_SIZE = sizeof(CommonHeader); // æ³¨æ„å¯¹é½å’Œå®é™…æ‰“åŒ…å¤§å°
    
    // --- ç‰¹å®šä¿¡ä»¤æ¶ˆæ¯ç»“æ„ä½“ ---
    struct InitiateCallRequest {
        std::string target_id;       // è¢«å«å·ç 
        uint32_t bandwidth_kbps;    // å¸¦å®½éœ€æ±‚
        // ... å…¶ä»–ç‰¹å®šå­—æ®µ
    };
    
    struct InitiateCallResponse {
        bool success;
        std::string zk_session_id;   // ZKä¾§ä¼šè¯æ ‡è¯†
        uint16_t bridge_media_port_for_zk; // Bridgeåˆ†é…ç»™ZKç”¨äºå‘é€åª’ä½“çš„ç«¯å£ (Bridgeæ¥æ”¶ZKåª’ä½“)
                                           // **æ›´æ­£: æ­¤å¤„åº”ä¸ºBridgeåˆ†é…ç”¨äºä»ZKæ¥æ”¶åª’ä½“çš„ç«¯å£ï¼Œ
                                           //  æˆ–ZKå‘ŠçŸ¥Bridgeå®ƒå°†ç”¨äºå‘é€åª’ä½“çš„ç«¯å£ï¼Œå…·ä½“çœ‹åè®®è®¾è®¡ã€‚
                                           //  å‡è®¾æ­¤å¤„æ˜¯Bridgeå‘ŠçŸ¥ZKï¼šâ€œä½ çš„åª’ä½“è¯·å‘å¾€æˆ‘çš„è¿™ä¸ªç«¯å£Xâ€
                                           //  æˆ–è€…ï¼Œå¦‚æœæ˜¯ZKå…ˆæŒ‡å®šï¼Œé‚£è¿™é‡Œæ˜¯ZKçš„ç«¯å£ã€‚
                                           //  æ ¹æ®ç”¨æˆ·æè¿° "zkå§‹ç»ˆç”¨ä¸€ä¸ªç«¯å£æ¥æ¥æ”¶200è·¯çš„ä¸šåŠ¡æ¶ˆæ¯ï¼Œ
                                           //  å› ä¸ºå‘é€ç»™zkæ¶ˆæ¯æ—¶ä¼šé€šè¿‡ä¸€ä¸ªå­—æ®µæ¥åŒºåˆ†ä¸åŒçš„sessionä¸šåŠ¡"
                                           //  ä»¥åŠ "bridgeå¯¹äºæ¯ä¸ªzkæœ‰ä¸€ä¸ªä¿¡ä»¤ç«¯å£å’Œä¸€è·¯ä¼šè¯å°±ä¸€ä¸ªä¸šåŠ¡ç«¯å£ï¼ˆå‘zkå‘é€çš„ï¼‰"
                                           //  è¿™æš—ç¤ºBridgeåˆ†é…ä¸€ä¸ªç«¯å£ç”¨äº *æ¥æ”¶* ZKç‰¹å®šä¼šè¯çš„åª’ä½“ï¼Œ
                                           //  æˆ–è€…ZKå‘å¾€Bridgeçš„å…±äº«ä¿¡ä»¤/åª’ä½“ç«¯å£åï¼ŒBridgeé€šè¿‡åŒ…å†…å­—æ®µåŒºåˆ†ã€‚
                                           //  æ­¤å¤„æˆ‘ä»¬å‡è®¾æ˜¯Bridgeåˆ†é…ç”¨äº*æ¥æ”¶*ZKåª’ä½“çš„ç«¯å£ã€‚
                                           //  ä½†ç”¨æˆ·æœ€æ–°æè¿°æ˜¯ZKæ‰€æœ‰ä¸šåŠ¡éƒ½ä»ä¸€ä¸ªç«¯å£å‘å‡ºåˆ°Bridgeçš„å¯¹åº”ZKä¿¡ä»¤ç«¯å£ã€‚
                                           //  æ‰€ä»¥æ­¤å­—æ®µå¯èƒ½ä¸éœ€è¦ï¼Œæˆ–è¡¨ç¤ºå…¶ä»–å«ä¹‰ã€‚
                                           //  **æš‚æ—¶ä»¥æ­¤ä¸ºBridgeåˆ†é…ç”¨äºæ¥æ”¶ZKåª’ä½“çš„ç«¯å£ï¼Œå¦‚æœZKä¼šç”¨ä¸åŒç«¯å£å‘åª’ä½“çš„è¯ã€‚
                                           //  å¦‚æœZKæ‰€æœ‰åª’ä½“éƒ½å‘å¾€Bridgeçš„ZKä¿¡ä»¤ç«¯å£ï¼Œåˆ™æ­¤å­—æ®µæ— ç›´æ¥å¯¹åº”ã€‚**
    
                                           // **æ ¹æ®æœ€æ–°ç†è§£ï¼ŒZKæ‰€æœ‰ä¸œè¥¿éƒ½å‘ç»™Bridgeçš„ZKä¿¡ä»¤/åª’ä½“ç»Ÿä¸€å…¥å£ã€‚
                                           // æ­¤å¤„å¯èƒ½ä¸ºBridgeåˆ†é…ç”¨äº *å‘ZKå‘é€åª’ä½“* çš„æœ¬åœ°æºç«¯å£ (ZKä¼šçœ‹åˆ°æ¥è‡ªæ­¤ç«¯å£çš„åª’ä½“)**
        std::string error_message;
    };
    
    // ... å…¶ä»–ä¿¡ä»¤æ¶ˆæ¯çš„ç»“æ„ä½“ ...
    
    
    // --- ç”¨äºåª’ä½“è½¬å‘çš„ç‰¹å®šç»“æ„ (ç”±MediaRelayè°ƒç”¨æœ¬æ¨¡å—çš„ç¼–ç å‡½æ•°) ---
    // è¿™ä¸ªç»“æ„å¯èƒ½ä¸æ˜¯ç›´æ¥é€šè¿‡ç½‘ç»œå‘é€çš„â€œæ¶ˆæ¯ç±»å‹â€ï¼Œè€Œæ˜¯MediaRelayéœ€è¦å°è£…çš„æ•°æ®
    struct MediaPacketToZk {
        CommonHeader common_zk_header; // ZKåè®®çš„å…¬å…±å¤´éƒ¨ (åºåˆ—å·ç­‰ç”±å¯é æ€§å±‚å¡«å……)
        // è¿™é‡Œæ˜¯çº¯åª’ä½“è´Ÿè½½ï¼Œå®é™…çš„â€œåŠ åŒ…å¤´â€å°±æ˜¯å¡«å……ä¸Šé¢çš„CommonHeader
        // å¹¶ç¡®ä¿æ•´ä¸ªåŒ…ç¬¦åˆZKåè®®å¯¹åª’ä½“æ•°æ®åŒ…çš„å®šä¹‰
    };
    
    
    // --- è§£æç»“æœçš„Variant ---
    using ParsedZkMessagePayload = std::variant<
        std::monostate, // è¡¨ç¤ºç©ºæˆ–æœªçŸ¥ï¼Œæˆ–åªæœ‰å…¬å…±å¤´éƒ¨
        InitiateCallRequest,
        InitiateCallResponse
        // ... å…¶ä»–ç‰¹å®šä¿¡ä»¤æ¶ˆæ¯çš„è½½è·ç»“æ„ä½“
    >;
    
    struct DecodedZkMessage {
        CommonHeader header;
        ParsedZkMessagePayload payload;
        // å¯ä»¥åŠ å…¥æ¥æºZKçš„æ ‡è¯†ï¼Œå¦‚æœé¡¶å±‚è§£æå‡½æ•°èƒ½è·å–åˆ°
    };
    
    
    } // namespace ZkProtocol
    ```
    
- **`zk_parser.h`**:
    
    C++
    
    ```
    #include "zk_message_types.h"
    #include <optional>
    
    namespace ZkProtocol::Parser {
    
    // é¡¶å±‚è§£æå‡½æ•°ï¼Œè´Ÿè´£è¯†åˆ«æ¶ˆæ¯ç±»å‹å¹¶åˆ†å‘
    std::optional<DecodedZkMessage> decode_packet(const unsigned char* buffer, size_t len);
    
    // (ä»¥ä¸‹å¯èƒ½æ˜¯å†…éƒ¨è¾…åŠ©å‡½æ•°ï¼Œæˆ–æ ¹æ®éœ€è¦æš´éœ²)
    // ZkMessageType get_message_type_from_header(const CommonHeader& header);
    // std::optional<InitiateCallRequest> decode_initiate_call_request_payload(const unsigned char* payload_buffer, size_t payload_len);
    // ... å…¶ä»–ç‰¹å®šæ¶ˆæ¯è½½è·çš„è§£ç å‡½æ•° ...
    
    } // namespace ZkProtocol::Parser
    ```
    
- **`zk_formatter.h`**:
    
    C++
    
    ```
    #include "zk_message_types.h"
    #include <vector>
    
    namespace ZkProtocol::Formatter {
    
    // é¡¶å±‚ç¼–ç å‡½æ•° (æ ¹æ®ä¼ å…¥çš„ç»“æ„ä½“ç±»å‹)
    std::vector<unsigned char> encode_message(const DecodedZkMessage& message); // æˆ–è€…ä¸ºæ¯ç§æ¶ˆæ¯æä¾›å•ç‹¬çš„encodeå‡½æ•°
    
    // (ä»¥ä¸‹å¯èƒ½æ˜¯å†…éƒ¨è¾…åŠ©å‡½æ•°ï¼Œæˆ–æ ¹æ®éœ€è¦æš´éœ²)
    // std::vector<unsigned char> encode_initiate_call_request(const CommonHeader& header, const InitiateCallRequest& payload);
    // ... å…¶ä»–ç‰¹å®šæ¶ˆæ¯çš„ç¼–ç å‡½æ•° ...
    
    // ç‰¹åˆ«ä¸ºMediaRelayæä¾›çš„ï¼Œç”¨äºå°è£…è£¸åª’ä½“æ•°æ®ä¸ºZKåª’ä½“åŒ…
    // header_template åº”åŒ…å«é™¤åºåˆ—å·ç­‰åŠ¨æ€å­—æ®µå¤–çš„å¤´éƒ¨ä¿¡æ¯
    // reliability_handler (åœ¨zk_interfaceä¸­) ä¼šåœ¨å‘é€å‰å¡«å†™æœ€ç»ˆçš„åºåˆ—å·ç­‰
    std::vector<unsigned char> encode_media_packet_for_zk(
        const CommonHeader& header_template, // å¯é æ€§å­—æ®µç”±è°ƒç”¨æ–¹ï¼ˆzk_interfaceçš„å¯é æ€§æ¨¡å—ï¼‰å¡«å……
        const unsigned char* media_payload,
        size_t media_payload_len
    );
    
    } // namespace ZkProtocol::Formatter
    ```
    

**8. å…³é”®å†…éƒ¨æ•°æ®ç»“æ„ (Key Internal Data Structures - åˆæ­¥è®¾æƒ³):**

- ä¸»è¦æ˜¯ä¸Šè¿° `zk_message_types.h` ä¸­å®šä¹‰çš„å„ç§æ¶ˆæ¯ç»“æ„ä½“ã€‚
- è§£æå‡½æ•°å†…éƒ¨å¯èƒ½ä½¿ç”¨ä¸´æ—¶çš„ã€åŸºäºçŠ¶æ€çš„è§£æå™¨ä¸Šä¸‹æ–‡ç»“æ„ï¼Œä½†è¿™äº›ä¸å…¬å¼€ã€‚

**9. éåŠŸèƒ½æ€§éœ€æ±‚è€ƒé‡ (NFRs):**

- **æ€§èƒ½:** ç¼–è§£ç æ“ä½œå¿…é¡»éå¸¸é«˜æ•ˆï¼Œé¿å…ä¸å¿…è¦çš„å†…å­˜æ‹·è´ã€‚
- **å¥å£®æ€§:** èƒ½å¤Ÿä¼˜é›…å¤„ç†æ ¼å¼é”™è¯¯ã€ä¸å®Œæ•´çš„æ•°æ®åŒ…ï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡è¿”å› `std::nullopt` æˆ–ç‰¹å®šçš„é”™è¯¯å¯¹è±¡ï¼‰ï¼Œå¹¶æä¾›è¶³å¤Ÿçš„é”™è¯¯ä¿¡æ¯ä¾›ä¸Šå±‚æ¨¡å—è®°å½•å’Œå¤„ç†ã€‚
- **æ­£ç¡®æ€§:** ä¸¥æ ¼æŒ‰ç…§ZKåè®®è§„èŒƒè¿›è¡Œç¼–è§£ç ï¼Œç‰¹åˆ«æ˜¯å­—èŠ‚åºã€å­—æ®µé•¿åº¦å’Œå¯¹é½ã€‚
- **å¯æµ‹è¯•æ€§:** å®¹æ˜“ä¸ºå„ç§æ¶ˆæ¯ç±»å‹å’Œè¾¹ç•Œæ¡ä»¶ç¼–å†™å•å…ƒæµ‹è¯•ã€‚

**10. å¾…è®¨è®º/æœªæ˜ç¡®ç‚¹ (Open Questions):**

- ZKåè®®æ˜¯å¦æœ‰å®˜æ–¹çš„ã€å­—èŠ‚çº§çš„è¯¦ç»†å®šä¹‰æ–‡æ¡£ï¼Ÿï¼ˆéå¸¸é‡è¦ï¼ï¼‰
- `CommonHeader` ä¸­çš„ `message_type` å­—æ®µæ˜¯å¦‚ä½•ç¡®å®šçš„ï¼Ÿå®ƒæ˜¯å¦è¶³ä»¥åŒºåˆ†æ‰€æœ‰é¡¶å±‚æ¶ˆæ¯ï¼Ÿ
- å¦‚æœæ¶ˆæ¯ä½“åŒ…å«â€œä¿¡æ¯å•å…ƒä¸ªæ•°â€å’Œå¤šä¸ªå¯å˜ç±»å‹/é•¿åº¦çš„â€œä¿¡æ¯å•å…ƒâ€ï¼Œ`decode_packet` å’Œç›¸å…³è½½è·è§£ç å‡½æ•°éœ€è¦å®ç°å¾ªç¯è§£æé€»è¾‘ã€‚
- é”™è¯¯å¤„ç†æœºåˆ¶ï¼šè§£æå¤±è´¥æ—¶ï¼Œæ˜¯è¿”å› `std::nullopt`ï¼Œè¿˜æ˜¯ä¸€ä¸ªåŒ…å«é”™è¯¯ç å’Œæè¿°çš„ `Result` ç±»å‹å¯¹è±¡ï¼Ÿ
- å­—èŠ‚åºï¼šæ˜ç¡®åè®®æ‰€æœ‰å¤šå­—èŠ‚å­—æ®µçš„å­—èŠ‚åºï¼ˆåº”ä¸ºç½‘ç»œå­—èŠ‚åºï¼‰ï¼Œå¹¶åœ¨ç¼–è§£ç æ—¶å¤„ç†ã€‚

---

#### **æ¨¡å— 1.2: `protocols/tms_protocol/` - TMS åè®®å¤„ç†æ¨¡å—**

- (è®¾è®¡æ€è·¯å’Œç»“æ„ä¸ `protocols/zk_protocol/` éå¸¸ç›¸ä¼¼ï¼Œåªæ˜¯é’ˆå¯¹TMSçš„åè®®è§„èŒƒè¿›è¡Œå®šä¹‰å’Œå®ç°)
- éœ€è¦æ˜ç¡®TMSä¿¡ä»¤æ˜¯é€šè¿‡TCPè¿˜æ˜¯UDPï¼Œä»¥åŠå…¶æ¶ˆæ¯æ ¼å¼ã€‚

---

### **ç¬¬äºŒéƒ¨åˆ†ï¼šé€šç”¨åŸºç¡€æ¨¡å— (Common Infrastructure)**

#### **æ¨¡å— 2.1: `common/communication/` - é€šä¿¡å±‚**

1. æ¦‚è¿° (Overview):

æä¾›åº•å±‚çš„ã€å¼‚æ­¥çš„ç½‘ç»œSocketæ“ä½œå°è£…ï¼Œä¸å…·ä½“çš„ZKæˆ–TMSåè®®æ— å…³ã€‚ä¸I/Oå¤ç”¨æœºåˆ¶ï¼ˆå¦‚epollï¼‰é›†æˆã€‚

**2. ä¸»è¦èŒè´£ (Key Responsibilities):**

- å°è£…å¼‚æ­¥UDP Socketçš„åˆ›å»ºã€ç»‘å®šã€æ•°æ®æ”¶å‘ (`async_udp_socket.{h,cpp}`)ã€‚
- å°è£…å¼‚æ­¥TCPå®¢æˆ·ç«¯Socketçš„åˆ›å»ºã€è¿æ¥ã€æ•°æ®æ”¶å‘ã€æ–­å¼€ (`async_tcp_client.{h,cpp}`) (ç”¨äºè¿æ¥TMSä¿¡ä»¤)ã€‚
- ï¼ˆå¯é€‰ï¼‰å°è£…å¼‚æ­¥TCPæœåŠ¡å™¨Socketçš„åˆ›å»ºã€ç›‘å¬ã€æ¥å—è¿æ¥ (`async_tcp_server.{h,cpp}`) (å¦‚æœBridgeéœ€è¦å¯¹å¤–æä¾›TCPç®¡ç†æ¥å£)ã€‚
- æ‰€æœ‰æ“ä½œéƒ½åº”è®¾è®¡ä¸ºéé˜»å¡çš„ï¼Œå¹¶èƒ½ä¸å¤–éƒ¨çš„äº‹ä»¶å¾ªç¯ï¼ˆå¦‚epollï¼‰é›†æˆï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡å›è°ƒå‡½æ•°ã€`std::future` æˆ–å…¶ä»–å¼‚æ­¥é€šçŸ¥æœºåˆ¶ï¼‰ã€‚

**3. æ ¸å¿ƒå¯¹å¤–æ¥å£ (Key Public APIs - åˆæ­¥è®¾æƒ³):**

- `AsyncUDPSocket::bind(ip, port)`
- `AsyncUDPSocket::async_receive_from(buffer, callback_on_received)`
- `AsyncUDPSocket::async_send_to(buffer, target_ip, target_port, callback_on_sent)`
- `AsyncTCPClient::async_connect(ip, port, callback_on_connected)`
- `AsyncTCPClient::async_send(buffer, callback_on_sent)`
- `AsyncTCPClient::async_receive(buffer, callback_on_received)`
- `AsyncTCPClient::close()`

**4. ä¾èµ–çš„å…¶ä»–æ¨¡å— (Dependencies):**

- æ“ä½œç³»ç»ŸSocket API (`<sys/socket.h>`, `<netinet/in.h>`, `<arpa/inet.h>`ç­‰ï¼Œæˆ–Boost.Asioç­‰ç½‘ç»œåº“)ã€‚
- I/Oå¤ç”¨æœºåˆ¶çš„å°è£… (å¯èƒ½åœ¨å†…éƒ¨å®ç°ï¼Œæˆ–ä¾èµ–å¤–éƒ¨äº‹ä»¶å¾ªç¯)ã€‚

**5. è¢«å“ªäº›æ¨¡å—ä¾èµ– (Depended On By):**

- `interfaces/zk_interface/`
- `interfaces/tms_interface/`

#### **æ¨¡å— 2.2: `common/task_queue/` - çº¿ç¨‹å®‰å…¨ä»»åŠ¡é˜Ÿåˆ—**

1. æ¦‚è¿° (Overview):

æä¾›ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„é˜Ÿåˆ—ï¼Œç”¨äºI/Oçº¿ç¨‹å‘å·¥ä½œçº¿ç¨‹æ± åˆ†å‘å¤„ç†ä»»åŠ¡ã€‚

**2. ä¸»è¦èŒè´£ (Key Responsibilities):**

- å®ç°çº¿ç¨‹å®‰å…¨çš„å…¥é˜Ÿ (`push`) å’Œå‡ºé˜Ÿ (`pop`/`try_pop`) æ“ä½œã€‚
- æ”¯æŒé˜»å¡ç­‰å¾…ï¼ˆå½“é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œå·¥ä½œçº¿ç¨‹å¯ä»¥ç­‰å¾…ï¼‰å’Œå”¤é†’æœºåˆ¶ã€‚

**3. æ ¸å¿ƒå¯¹å¤–æ¥å£ (Key Public APIs - åˆæ­¥è®¾æƒ³):**

C++

```
template<typename T> // T æ˜¯ä»»åŠ¡å¯¹è±¡çš„ç±»å‹
class ConcurrentQueue {
public:
    void push(T task);
    bool try_pop(T& out_task);
    T wait_and_pop(); // é˜»å¡ç›´åˆ°æœ‰ä»»åŠ¡
    // ...
};
```

- ä»»åŠ¡å¯¹è±¡ `T` å¯ä»¥æ˜¯ä¸€ä¸ª `std::function<void()>`ï¼Œæˆ–è€…ä¸€ä¸ªåŒ…å«å¤„ç†æ‰€éœ€æ•°æ®çš„è‡ªå®šä¹‰ç»“æ„ä½“ã€‚

**4. ä¾èµ–çš„å…¶ä»–æ¨¡å— (Dependencies):**

- C++æ ‡å‡†åº“ (`<queue>`, `<mutex>`, `<condition_variable>`)ã€‚

**5. è¢«å“ªäº›æ¨¡å—ä¾èµ– (Depended On By):**

- I/Oçº¿ç¨‹ (ç”Ÿäº§è€…)
- å·¥ä½œçº¿ç¨‹æ±  (æ¶ˆè´¹è€…)

#### **æ¨¡å— 2.3: `logging/` - æ—¥å¿—æ¨¡å—**

1. æ¦‚è¿° (Overview):

æä¾›å…¨å±€çš„ã€å¯é…ç½®çš„ã€é«˜æ€§èƒ½çš„æ—¥å¿—è®°å½•åŠŸèƒ½ã€‚æ¨èä½¿ç”¨ spdlogã€‚

**2. ä¸»è¦èŒè´£ (Key Responsibilities):**

- åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿï¼ˆä¾‹å¦‚ï¼Œè®¾ç½®æ—¥å¿—çº§åˆ«ã€è¾“å‡ºæ ¼å¼ã€ç›®æ ‡æ–‡ä»¶/æ§åˆ¶å°ï¼‰ã€‚
- æä¾›ä¸åŒæ—¥å¿—çº§åˆ«çš„è®°å½•æ¥å£ï¼ˆDEBUG, INFO, WARN, ERROR, CRITICALï¼‰ã€‚
- ï¼ˆå¯é€‰ï¼‰æ”¯æŒå¼‚æ­¥æ—¥å¿—è®°å½•ä»¥å‡å°‘å¯¹ä¸šåŠ¡çº¿ç¨‹çš„å½±å“ã€‚

**3. æ ¸å¿ƒå¯¹å¤–æ¥å£ (Key Public APIs - åˆæ­¥è®¾æƒ³):**

- (é€šå¸¸æ˜¯å¯¹ `spdlog` çš„ç®€å•å°è£…æˆ–ç›´æ¥ä½¿ç”¨å…¶API)
- `Logger::init(...)`
- `LOG_DEBUG("message with arg {}", arg1)`
- `LOG_INFO(...)`, `LOG_WARN(...)`, `LOG_ERROR(...)`

**4. è¢«å“ªäº›æ¨¡å—ä¾èµ– (Depended On By):**

- å‡ ä¹æ‰€æœ‰å…¶ä»–æ¨¡å—ã€‚

---

### **ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ ¸å¿ƒé€»è¾‘æ¨¡å— (Core Logic)**

#### **æ¨¡å— 3.1: `core_logic/config_manager/` - é…ç½®ç®¡ç†å™¨**

1. æ¦‚è¿° (Overview):

è´Ÿè´£åœ¨ç¨‹åºå¯åŠ¨æ—¶åŠ è½½æ‰€æœ‰å¿…è¦çš„é…ç½®ä¿¡æ¯ï¼Œå¹¶æä¾›ç»™å…¶ä»–æ¨¡å—è®¿é—®ã€‚

**2. ä¸»è¦èŒè´£ (Key Responsibilities):**

- ä»é…ç½®æ–‡ä»¶ï¼ˆä¾‹å¦‚JSONæ ¼å¼ï¼‰ä¸­è¯»å–ï¼š
    - Bridgeè‡ªèº«çš„ç›‘å¬è®¾ç½®ï¼ˆä¾‹å¦‚ï¼Œç”¨äºZKä¿¡ä»¤çš„10ä¸ªç«¯å£ï¼ŒTMSä¿¡ä»¤ç«¯å£ï¼‰ã€‚
    - TMSæœåŠ¡å™¨çš„è¿æ¥ä¿¡æ¯ (IP, Port)ã€‚
    - ZKå®ä½“çš„åŸºç¡€ä¿¡æ¯åˆ—è¡¨ (å¦‚æœæ¯ä¸ªZKæœ‰ç‰¹å®šé…ç½®éœ€è¦é¢„åŠ è½½)ã€‚
    - "cué…ç½®è¡¨" å’Œ "cuå’Œtarget_idæ˜ å°„è¡¨"ã€‚
    - ç«¯å£ç®¡ç†å™¨å¯ç”¨çš„ç«¯å£èŒƒå›´ã€‚
    - æ—¥å¿—çº§åˆ«ã€çº¿ç¨‹æ± å¤§å°ç­‰ç³»ç»Ÿå‚æ•°ã€‚
- è§£æå¹¶æ ¡éªŒé…ç½®ä¿¡æ¯çš„æœ‰æ•ˆæ€§ã€‚
- æä¾›çº¿ç¨‹å®‰å…¨çš„æ¥å£ä¾›å…¶ä»–æ¨¡å—æŸ¥è¯¢é…ç½®ã€‚é…ç½®é€šå¸¸åœ¨å¯åŠ¨åæ˜¯åªè¯»çš„ã€‚

**3. æ ¸å¿ƒå¯¹å¤–æ¥å£ (Key Public APIs - åˆæ­¥è®¾æƒ³):**

- `ConfigManager::instance().load_config(const std::string& filepath);`
- `const TmsConfig& ConfigManager::instance().get_tms_config();`
- `std::optional<ZkConfig> ConfigManager::instance().get_zk_config(const ZkId& zk_id);`
- `const CuConfigTable& ConfigManager::instance().get_cu_config_table();`
- `// ...`

**4. ä¾èµ–çš„å…¶ä»–æ¨¡å— (Dependencies):**

- JSONè§£æåº“ (ä¾‹å¦‚ `nlohmann/json`)ã€‚
- C++æ ‡å‡†åº“ (`<fstream>`, `<string>`, `<vector>`, `<map>`)ã€‚

**5. è¢«å“ªäº›æ¨¡å—ä¾èµ– (Depended On By):**

- å‡ ä¹æ‰€æœ‰å…¶ä»–æ¨¡å—åœ¨åˆå§‹åŒ–æˆ–è¿è¡Œæ—¶éƒ½éœ€è¦é…ç½®ä¿¡æ¯ã€‚

---

**(æ¥ä¸‹æ¥çš„æ¨¡å—å®šä¹‰ï¼Œå¦‚ `interfaces/*`, `Coordinator`, `SessionManager`, `Session`, `PortManager`, `MediaRelay` å°†éµå¾ªç±»ä¼¼çš„æ¨¡æ¿ï¼Œç»†åŒ–å…¶èŒè´£ã€æ¥å£å’Œå…³é”®æ•°æ®ç»“æ„ï¼Œå¹¶ç‰¹åˆ«å¼ºè°ƒå®ƒä»¬å¦‚ä½•åœ¨å¤šçº¿ç¨‹å’Œäº‹ä»¶é©±åŠ¨æ¨¡å‹ä¸‹å·¥ä½œï¼Œä»¥åŠå¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨ã€‚) **

**ä¾‹å¦‚ï¼Œå¯¹äº `Session` å¯¹è±¡ï¼Œå…¶æ ¸å¿ƒèŒè´£ä¹‹ä¸€å°±æ˜¯å®ç°ä¸€ä¸ªçŠ¶æ€æœºæ¥ç®¡ç†å‘¼å«çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸï¼Œå®ƒçš„æ–¹æ³•ï¼ˆå¦‚ `handleZkEvent`ï¼‰å°†åœ¨å·¥ä½œçº¿ç¨‹ä¸­è¢«è°ƒç”¨ã€‚**

**å¯¹äº `MediaRelay`ï¼Œå…¶å†…éƒ¨çš„è½¬å‘è¡¨åœ¨è¢«å·¥ä½œçº¿ç¨‹ï¼ˆç”±Sessioné€»è¾‘é©±åŠ¨ï¼‰æ›´æ–°æ—¶éœ€è¦åŠ é”ï¼Œè€ŒI/Oçº¿ç¨‹åœ¨è¯»å–è½¬å‘è¡¨è¿›è¡Œåª’ä½“è½¬å‘æ—¶ï¼Œå¯ä»¥ä½¿ç”¨æ›´è½»é‡çº§çš„åŒæ­¥æœºåˆ¶ï¼ˆå¦‚è¯»å†™é”æˆ–æ— é”æ•°æ®ç»“æ„ï¼Œå¦‚æœé€‚ç”¨ä¸”å®ç°æ­£ç¡®çš„è¯ï¼‰ï¼Œæˆ–è€…ä¿è¯è½¬å‘è¡¨çš„æ›´æ–°æ˜¯éå¸¸å¿«é€Ÿçš„åŸå­æ“ä½œï¼ˆä¾‹å¦‚æ›¿æ¢æŒ‡é’ˆï¼‰æ¥æœ€å°åŒ–å¯¹I/Oçº¿ç¨‹çš„å½±å“ã€‚**

---

è¿™ä¸ªè¯¦ç»†è®¾è®¡è¿‡ç¨‹ä¼šæ¯”è¾ƒè€—æ—¶ï¼Œä½†å¯¹äºåç»­çš„é¡ºåˆ©å¼€å‘è‡³å…³é‡è¦ã€‚æˆ‘ä»¬å¯ä»¥å…ˆé›†ä¸­ç²¾åŠ›æŠŠ `protocols/zk_protocol/` æ¨¡å—çš„ **æ ¸å¿ƒå¯¹å¤–æ¥å£ (ç‰¹åˆ«æ˜¯æ¶ˆæ¯ç»“æ„ä½“å’Œç¼–è§£ç å‡½æ•°ç­¾å)** ç¡®å®šä¸‹æ¥ï¼Œå› ä¸ºè¿™æ˜¯å¾ˆå¤šå…¶ä»–æ¨¡å—çš„åŸºç¡€ã€‚

ç„¶åæˆ‘ä»¬å¯ä»¥è®¨è®º `interfaces/zk_interface/` å¦‚ä½•ä½¿ç”¨å®ƒï¼Œä»¥åŠå®ƒå¦‚ä½•ä¸I/Oçº¿ç¨‹å’Œå·¥ä½œçº¿ç¨‹æ± çš„ä»»åŠ¡é˜Ÿåˆ—äº¤äº’ã€‚

æ‚¨è§‰å¾—è¿™ä¸ªæ–¹å‘å’Œç»†åŒ–ç¨‹åº¦å¦‚ä½•ï¼Ÿæˆ‘ä»¬å¯ä»¥å…ˆé’ˆå¯¹ `protocols/zk_protocol/` æŠŠç¬¬7ç‚¹â€œæ ¸å¿ƒå¯¹å¤–æ¥å£â€å†å…·ä½“åŒ–ä¸€ä¸‹å—ï¼Ÿä¾‹å¦‚ï¼Œæ‚¨ZKåè®®ä¸­æœ€é‡è¦çš„å‡ æ¡ä¿¡ä»¤æ¶ˆæ¯æ˜¯ä»€ä¹ˆï¼Ÿå®ƒä»¬åŒ…å«å“ªäº›å…³é”®å­—æ®µï¼Ÿ