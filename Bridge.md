#### ç³»ç»Ÿæ¦‚è¿°ï¼š
	å­˜åœ¨å®ä½“ tmsï¼Œå’Œzkï¼Œå…¶ä¸­zkæœ‰1-10ä¸ªã€‚è€Œtmsæœ‰ä¸€ä¸ªã€‚ zkå’Œtmsæœ‰å„è‡ªçš„åè®®ï¼Œæ‰€ä»¥å½“zkè¦å’Œtmsæ²Ÿé€šæ—¶éœ€è¦ä¸€ä¸ªä¸­é—´æ¡¥æ¢ç¨‹åº ï¼šBridge

#### ä¸»è¦æ ¸å¿ƒåœºæ™¯ï¼š

- æ”¶åˆ°zkå‘èµ·é€šå‘Šéœ€æ±‚ 
- brdigeè§£æé€šå‘Šéœ€æ±‚ï¼Œæå–target_id,ç­‰å‚æ•° 
- è½¬å‘é€šå‘Šéœ€æ±‚åˆ°tms
- å’Œtmså®Œæˆä¼šè¯ä¿¡ä»¤äº¤äº’è¿‡ç¨‹ ï¼ŒæˆåŠŸè¿›å…¥ä¸šåŠ¡é€šä¿¡
- å°†æ”¶åˆ°çš„zkçš„ä¸šåŠ¡é€šä¿¡ï¼Œè½¬å‘åˆ°å¯¹åº”çš„tmsä¾§çš„ç»ˆç«¯
- å°†æ”¶åˆ°çš„tmsä¾§çš„ä¸šåŠ¡é€šä¿¡è½¬å‘åˆ°å¯¹åº”çš„zk

- æ”¶åˆ°zk æ‹†é“¾é€šå‘Šéœ€æ±‚
- bridge è½¬å‘æ­¤éœ€æ±‚åˆ°tms
- tmså’Œbridgeæ‹†é“¾ä¿¡ä»¤äº¤äº’
- ä¸šåŠ¡é€šä¿¡æ‹†é™¤


##### è¯¦ç»†æ ¸å¿ƒåœºæ™¯æµç¨‹
- ç¨‹åºå¯åŠ¨
	- ä»é…ç½®æ–‡ä»¶ä¸­åŠ è½½cué…ç½®è¡¨ï¼Œcuå’Œtarget_idæ˜ å°„è¡¨
	-  åŠ è½½tms,zk çš„ip port åŒæ—¶å¯åŠ¨ç›‘å¬æµç¨‹
	- å’Œtmså»ºç«‹å¿ƒè·³ï¼Œå½“å­˜åœ¨å¿ƒè·³æ—¶ï¼Œä¸ŠæŠ¥è®¾å¤‡çŠ¶æ€åˆ°zk
- ç¨‹åºè¿è¡Œï¼š
	- ç›‘å¬åˆ°æ¥è‡ªzkçš„æŠ¥æ–‡
	- è¿™é‡Œå¥½åƒåè®®è‡ªå·±å°è£…äº†å¯é æ€§æœºåˆ¶
	- åˆ¤æ–­ç±»å‹ä¸º éœ€æ±‚é€šå‘Š
	- åˆ¤æ–­å†…å®¹ä¸ºå»ºç«‹ç‚¹å¯¹ç‚¹é€šä¿¡
	- æå–è¢«å«å·ç ï¼Œå¸¦å®½
	- é€šè¿‡å·ç  è¯»å–ç›¸åº”é…ç½®
	- åˆ›å»ºç‚¹å¯¹ç‚¹ä¼šè¯è¡¨ï¼Œå¹¶å¡«å…¥zk_ipï¼Œè¢«å«å·ç ï¼Œå¸¦å®½ï¼Œé…ç½®ï¼Œè‡ªåŠ¨åˆ†é… bridge->zk ä¸šåŠ¡ç«¯å£ï¼Œbridge->tmsä¸šåŠ¡ç«¯å£
	- ä¼šè¯è¡¨è§¦å‘tmsä¾§å‘èµ·å‘¼å«
	- é€šè¿‡tcpå‘é€
	- æ¥æ”¶tcpå“åº”ï¼Œæ›´æ–°ä¼šè¯è¡¨çŠ¶æ€
	- ä¼šè¯è¡¨æ£€æµ‹åˆ°ä¹‹å
	- è§£æä¸šåŠ¡ç«¯å£ï¼Œæ›´æ–°åˆ°ä¼šè¯è¡¨ä¸­
    - 

å®ä½“2å‘é€é€šå‘Šæ‹†é“¾Â Â 


è§£ææ‹†é“¾æ¶ˆæ¯Â Â 

  

æå–ç›®çš„ç»ˆç«¯,é€šè¿‡ç›®çš„ç»ˆç«¯å’Œç«™æ§idæ¥æŸ¥æ‰¾ä¼šè¯Â Â 

  

æ›´æ–°ä¼šè¯çŠ¶æ€ä¸ºæ­£åœ¨å…³é—­Â Â 

  

é€šè¿‡sessionæ•°æ®ç»“æ„ è®¿é—®å…¶ä¸­çš„cuå·æ¥å‘tmså‘é€å‘¼å«æŒ‚æ–­Â Â 

  

Â·æ”¶åˆ°å‘¼å«æŒ‚æ–­å“åº”Â Â 

  

Â·é€šè¿‡cuå·æ¥æŸ¥æ‰¾sessionç»“æ„ä½“å¹¶æ›´æ–°å…¶ä¸­çš„çŠ¶æ€Â Â 

  

æ›´æ–°sessionæ•°æ®ç»“æ„ä¸­çš„çŠ¶æ€Â Â 

  

å›æ”¶brdige->tmsä¸šåŠ¡udpç«¯å£åŠsocketï¼Œå›æ”¶brdige->zkudpç«¯å£å’ŒsocketÂ Â 

  

æ›´æ–°sessionä¸­çŠ¶æ€ä¸ºå·²ç»æ‹†é“¾Â Â 

  

é‡Šæ”¾sessionæ•°æ®ç»“æ„ è¯·ä½ è®¾è®¡ä¸€ä¸ªæ¶æ„ æˆ‘å†…å¿ƒå·²ç»æœ‰ä¸€ä¸ªæ¶æ„äº† æˆ‘æƒ³å’Œä½ æ¯”ä¸€ä¸‹è°è®¾è®¡çš„æ›´å¥½

#### ç»“æ„è®¾è®¡ï¼š
- zk_interface: è´Ÿè´£zkåè®®çš„æ•°æ®ç»“æ„å®ç°ï¼Œä»¥åŠè¿™äº›æ•°æ®ç»“æ„çš„æ–¹æ³•ï¼Œåˆ›å»ºæ–¹æ³•å’Œè§£ææ–¹æ³•



ubuntu16.04 è™šæ‹Ÿæœºé•œåƒ å¯†ç  1234



FROM ubuntu:20.04

# é¿å…äº¤äº’å¼å®‰è£…

ENV DEBIAN_FRONTEND=noninteractive

# å®‰è£…å¼€å‘å·¥å…·

RUN apt-get update && apt-get install -y \

build-essential \

cmake \

gdb \

git \

curl \

wget \

vim \

nano \

pkg-config \

valgrind \

&& rm -rf /var/lib/apt/lists/*

# åˆ›å»ºå¼€å‘ç”¨æˆ·

RUN useradd -m -s /bin/bash developer && \

usermod -aG sudo developer && \

echo 'developer:developer' | chpasswd && \

echo 'developer ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers

# è®¾ç½®å·¥ä½œç›®å½•

WORKDIR /workspace

# åˆ‡æ¢åˆ°å¼€å‘ç”¨æˆ·

USER developer

# è®¾ç½®ç¼–è¯‘ç¯å¢ƒå˜é‡ï¼ˆå…¼å®¹æ€§ä¼˜å…ˆï¼‰

ENV CXXFLAGS="-std=c++11"

ENV CC=gcc

ENV CXX=g++

è¿™æ˜¯æˆ‘çš„docker fileæ–‡ä»¶ æ¯æ¬¡æˆ‘è¿›å»è¿™ä¸ªå·¥ç¨‹ éƒ½æç¤ºæˆ‘è¦å®‰è£… æ’ä»¶ ä½†æ˜¯å®‰è£…å®Œä»¥å å½“æˆ‘è¿æ¥è¿™äº›å®¹å™¨ æ—¶ åˆæç¤ºæˆ‘ osç‰ˆæœ¬å¤ªè€äº† ä½†æ˜¯æˆ‘è§‰å¾— ä¸å¤ªå¯¹ï¼Œå› ä¸ºæˆ‘çš„é•œåƒæ˜¯20.04çš„ä¸å¯èƒ½æ˜¯è¿™ä¸ªåŸå›  æˆ‘çš„ç†è§£å°±æ˜¯è¿æ¥æ—¶ è¿æ¥åˆ°äº†é”™è¯¯çš„å®¹å™¨ ä¸Š ä½†æ˜¯å¥½åƒå·¥ç¨‹ä¸‹çš„æœ‰ä¸¤ä¸ªé…ç½®æ–‡ä»¶ ä¸€ä¸ªdevcontainer.json ä¸€ä¸ªdockerfile æˆ‘ç°åœ¨éœ€è¦å¼„æ¸…æ¥šä¸€äº›åŸºæœ¬çš„æ¦‚å¿µ ï¼Œ ä½ æ¥å‘Šè¯‰æˆ‘è¿™ä¸¤ä¸ªé…ç½®æ–‡ä»¶ æ˜¯å¹²å˜›ç”¨çš„ ï¼Œè°¢è°¢Â 

è€Œä¸”ç”±äºæˆ‘æƒ³åœ¨è¿™ä¸ªdockeré‡Œä½¿ç”¨äº¤å‰ç¼–è¯‘






Okay, here's a structural design document for your C++ "Bridge" application, incorporating our discussions on I/O multiplexing, event-driven architecture, and multithreading. I'll also address your question about using JSON, spdlog, and Redis.

Yes, you absolutely **should consider using libraries like a JSON parser, spdlog, and Redis**, especially given your requirements:

- **JSON Library (e.g., nlohmann/json, RapidJSON):** Excellent for reading configuration files if they are in JSON format. This simplifies configuration management significantly.
- **spdlog:** A very good choice for high-performance, flexible, and structured logging in C++. Logging is crucial for debugging and monitoring any server application.
- **Redis:** Forä¸»å¤‡å®¹ç¾ (active-standby disaster recovery), Redis is a strong candidate. It can be used to store and replicate active session state. If a primary Bridge instance fails, a standby instance can potentially take over by loading session information from Redis, allowing for more seamless failover or graceful termination of existing calls.

---

## Bridge ç³»ç»Ÿç»“æ„è®¾è®¡è¯´æ˜æ–‡æ¡£

æœ¬æ–‡æ¡£æè¿°äº† Bridge ç³»ç»Ÿçš„ç»“æ„è®¾è®¡ï¼Œè¯¥ç³»ç»Ÿä½œä¸º ZK å®ä½“å’Œ TMS ç³»ç»Ÿä¹‹é—´çš„ä¸­é—´æ¡¥æ¢ï¼Œæ”¯æŒä¿¡ä»¤å’Œåª’ä½“ä¸šåŠ¡çš„è½¬å‘ã€‚è®¾è®¡è€ƒè™‘äº†é«˜æ€§èƒ½ã€é«˜å¹¶å‘ã€å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§ï¼Œé‡‡ç”¨äº†I/Oå¤ç”¨ã€äº‹ä»¶é©±åŠ¨å’Œå¤šçº¿ç¨‹çš„æ¶æ„ã€‚

---

### 1. æ ¸å¿ƒè®¾è®¡åŸåˆ™ ğŸŒŸ

- **æ¨¡å—åŒ–:** ç³»ç»Ÿåˆ’åˆ†ä¸ºå…·æœ‰æ˜ç¡®èŒè´£çš„ç‹¬ç«‹æ¨¡å—ã€‚
- **å¼‚æ­¥éé˜»å¡:** I/Oæ“ä½œå’Œæ ¸å¿ƒé€»è¾‘é‡‡ç”¨å¼‚æ­¥éé˜»å¡æ¨¡å¼ï¼Œä»¥æé«˜å¹¶å‘å¤„ç†èƒ½åŠ›ã€‚
- **äº‹ä»¶é©±åŠ¨:** ç³»ç»Ÿç”±å¤–éƒ¨äº‹ä»¶ï¼ˆå¦‚ç½‘ç»œæ¶ˆæ¯ã€å®šæ—¶å™¨ï¼‰å’Œå†…éƒ¨äº‹ä»¶ï¼ˆä»»åŠ¡å®Œæˆï¼‰é©±åŠ¨ã€‚
- **çº¿ç¨‹åˆ†ç¦»:** I/Oå¯†é›†å‹ä»»åŠ¡ä¸CPUå¯†é›†å‹ï¼ˆæˆ–ä¸šåŠ¡é€»è¾‘ï¼‰ä»»åŠ¡ç”±ä¸åŒç±»å‹çš„çº¿ç¨‹å¤„ç†ã€‚
- **ä¼šè¯ä¸­å¿ƒåŒ–:** `Session` å¯¹è±¡å°è£…äº†å•ä¸ªç«¯åˆ°ç«¯å‘¼å«çš„æ ¸å¿ƒçŠ¶æ€å’Œé€»è¾‘ã€‚
- **çº¿ç¨‹å®‰å…¨:** æ‰€æœ‰å…±äº«èµ„æºï¼ˆä¼šè¯è¡¨ã€ç«¯å£æ± ã€åª’ä½“è½¬å‘è¡¨ç­‰ï¼‰çš„è®¾è®¡éƒ½å¿…é¡»è€ƒè™‘çº¿ç¨‹å®‰å…¨ã€‚

---

### 2. æ€»ä½“æ¶æ„å›¾ (æ¦‚å¿µ)

```
+---------------------+      +-----------------------+      +---------------------+
|     ZK Entities     |<---->|      ZK Interface     |<---->|                     |
| (10 ZKs, 1 port ea. |      | (10 Listeners,        |      |                     |
|  Signaling & Media) |      |  Demux, Proto Handler) |      |   Coordinator /   |
+---------------------+      +-----------+-----------+      |   Event Router    |      +-------------------+
                                         ^                          |                     |----->|  Session Module   |
                                         |                          v                     |<-----| (SessionManager,  |
                                         | (Tasks)           +------+------+              |      |  Session Objects) |
                                         |                   | Task Queue  |              |      +-------------------+
                                         v                   +------+------+              |                |
+---------------------+      +-----------+-----------+              | (Tasks)            |                | (Config MediaRelay)
|     TMS System      |<---->|     TMS Interface     |<-------------+                     |                v
| (1 TCP Sig, N UDP   |      | (TCP Conn, N UDP Listen,|             v                     |      +-------------------+
|  Media from TMS)    |      |  Proto Handler)       |      +-----------------------+      |----->| MediaRelay Module |
+---------------------+      +-----------------------+      |   Worker Thread Pool  |------      |(Fast Fwd Table,   |
                                                            +-----------------------+             | Header Manip.)    |
                                                                                                  +-------------------+
                                                                     |  ^
                                                                     |  | (Alloc/Release)
                                                                     v  |
+-----------------------+     +-----------------------+     +-----------------------+
| Communication Layer   |<--->|    Protocol Layer     |<--->|    Port Manager       |
| (Async Sockets)       |     | (ZK/TMS Parsers/Fmts) |     | (UDP Port Pool)       |
+-----------------------+     +-----------------------+     +-----------------------+

+-----------------------+     +-----------------------+
| Configuration Manager |     |     Logging (spdlog)  |
| (JSON for config)     |     +-----------------------+
+-----------------------+

+-----------------------+
| Redis (Optional for HA|
| Session State Sync)   |
+-----------------------+
```

---

### 3. çº¿ç¨‹æ¨¡å‹ ğŸ§µ

- **I/O çº¿ç¨‹ (å°‘é‡, e.g., `num_cores / 2` æˆ– `num_cores`):**
    - è¿è¡Œ `epoll` (æˆ–ç­‰æ•ˆçš„) äº‹ä»¶å¾ªç¯ã€‚
    - è´Ÿè´£æ‰€æœ‰Socketçš„éé˜»å¡è¯»å†™ã€‚
    - è¿›è¡Œæœ€åŸºæœ¬çš„æ•°æ®åŒ…è§£æï¼ˆå¦‚è¯†åˆ«æ¥æºã€åˆ¤æ–­æ˜¯ä¿¡ä»¤è¿˜æ˜¯åª’ä½“ï¼Œæå–ä¼šè¯æ ‡è¯†ç¬¦ï¼‰ã€‚
    - å°†è§£æåçš„ä»»åŠ¡ï¼ˆå°è£…äº†æ•°æ®å’Œä¸Šä¸‹æ–‡ï¼‰æ”¾å…¥ä»»åŠ¡é˜Ÿåˆ—ï¼Œäº¤ç”±å·¥ä½œçº¿ç¨‹æ± å¤„ç†ã€‚
    - ç›´æ¥å¤„ç†æä½å»¶è¿Ÿçš„åª’ä½“è½¬å‘ï¼ˆå¦‚æœåŒ…å¤´æ“ä½œç®€å•ï¼‰ã€‚
- **å·¥ä½œçº¿ç¨‹æ±  (å›ºå®šæ•°é‡, e.g., `num_cores` æˆ–æ›´å¤š):**
    - ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡ã€‚
    - æ‰§è¡Œæ‰€æœ‰æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼š`Session` å¯¹è±¡çš„åˆ›å»ºã€çŠ¶æ€æ›´æ–°ã€å†³ç­–ï¼›ä¸ `ConfigManager`ã€`PortManager` äº¤äº’ï¼›å‡†å¤‡ä¿¡ä»¤æ•°æ®ï¼›é€šè¿‡ `Coordinator` æŒ‡ç¤ºæ¥å£å±‚å‘é€æ¶ˆæ¯ï¼›é…ç½® `MediaRelay`ã€‚
- **å¯é€‰çš„ä¸“ç”¨çº¿ç¨‹ï¼š**
    - TMSå¿ƒè·³çº¿ç¨‹ã€‚
    - å®šæ—¶æ¸…ç†çº¿ç¨‹ (å¦‚æ¸…ç†è¿‡æœŸä¼šè¯)ã€‚

---

### 4. ä»£ç ç»“æ„ä¸æ¨¡å—è¯´æ˜

```
bridge_system/
â”œâ”€â”€ main.cpp                     # ç¨‹åºå…¥å£, åˆå§‹åŒ–å„æ¨¡å—, å¯åŠ¨I/Oäº‹ä»¶å¾ªç¯å’Œå·¥ä½œçº¿ç¨‹æ± 
â”‚
â”œâ”€â”€ common/                      # é€šç”¨åŸºç¡€æ¨¡å—
â”‚   â”œâ”€â”€ communication/           # åº•å±‚å¼‚æ­¥ç½‘ç»œé€šä¿¡å°è£…
â”‚   â”‚   â”œâ”€â”€ async_udp_socket.{h,cpp}
â”‚   â”‚   â””â”€â”€ async_tcp_client.{h,cpp} # (å¦‚æœTMSä¿¡ä»¤æ˜¯Clientæ¨¡å¼)
â”‚   â”‚   â””â”€â”€ async_tcp_server.{h,cpp} # (å¦‚æœTMSä¿¡ä»¤æ˜¯Serveræ¨¡å¼æˆ–ç®¡ç†æ¥å£)
â”‚   â”œâ”€â”€ task_queue/              # çº¿ç¨‹å®‰å…¨çš„ä»»åŠ¡é˜Ÿåˆ— (I/Oçº¿ç¨‹ä¸å·¥ä½œçº¿ç¨‹äº¤äº’)
â”‚   â”‚   â””â”€â”€ concurrent_queue.h
â”‚   â””â”€â”€ utils/                   # å…¶ä»–å·¥å…·ç±» (e.g., string manipulation, timers)
â”‚       â””â”€â”€ ...
â”‚
â”œâ”€â”€ protocols/                   # åè®®å®šä¹‰ä¸ç¼–è§£ç  (æ— çŠ¶æ€å·¥å…·åº“)
â”‚   â”œâ”€â”€ zk_protocol/
â”‚   â”‚   â”œâ”€â”€ zk_message_types.h   # ZKåè®®æ¶ˆæ¯çš„C++ç»“æ„ä½“å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ zk_parser.{h,cpp}    # è§£æZKå­—èŠ‚æµ -> ç»“æ„ä½“
â”‚   â”‚   â””â”€â”€ zk_formatter.{h,cpp} # ç»“æ„ä½“ -> ZKå­—èŠ‚æµ
â”‚   â””â”€â”€ tms_protocol/
â”‚       â”œâ”€â”€ tms_message_types.h
â”‚       â”œâ”€â”€ tms_parser.{h,cpp}
â”‚       â””â”€â”€ tms_formatter.{h,cpp}
â”‚
â”œâ”€â”€ interfaces/                  # å¤–éƒ¨ç³»ç»Ÿæ¥å£é€‚é…å±‚
â”‚   â”œâ”€â”€ zk_interface/
â”‚   â”‚   â”œâ”€â”€ zk_listener.{h,cpp}  # ç®¡ç†10ä¸ªUDPç›‘å¬Socket (æ¥æ”¶ZKä¿¡ä»¤å’Œåª’ä½“)
â”‚   â”‚   â”‚                        # åŠŸèƒ½: ä½¿ç”¨communicationå±‚, æ³¨å†Œåˆ°epoll, è¯»å–æ•°æ®,
â”‚   â”‚   â”‚                        #       åˆæ­¥è§£æ(è¯†åˆ«ZK ID, ä¼šè¯ID, ä¿¡ä»¤/åª’ä½“),
â”‚   â”‚   â”‚                        #       åˆ›å»ºä»»åŠ¡å¹¶æ”¾å…¥TaskQueueæˆ–ç›´æ¥è°ƒç”¨MediaRelay
â”‚   â”‚   â”œâ”€â”€ zk_sender.{h,cpp}    # å°è£…å‘ZKå‘é€æ•°æ® (ä½¿ç”¨communicationå±‚å’Œzk_formatter)
â”‚   â”‚   â””â”€â”€ zk_defs.h            # ZKæ¥å£ç›¸å…³çš„å†…éƒ¨å¸¸é‡/å®šä¹‰
â”‚   â””â”€â”€ tms_interface/
â”‚       â”œâ”€â”€ tms_connector.{h,cpp}# ç®¡ç†ä¸TMSçš„TCPä¿¡ä»¤è¿æ¥ (å¿ƒè·³, æ”¶å‘)
â”‚       â”œâ”€â”€ tms_media_listener.{h,cpp} # ç®¡ç†Nä¸ªUDPç›‘å¬Socket (æ¥æ”¶TMSåª’ä½“)
â”‚       â”œâ”€â”€ tms_sender.{h,cpp}   # å°è£…å‘TMSå‘é€æ•°æ®
â”‚       â””â”€â”€ tms_defs.h
â”‚
â”œâ”€â”€ core_logic/                  # æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ coordinator.{h,cpp}      # åè°ƒå™¨/è·¯ç”±å™¨: åœ¨æ¥å£å±‚å’Œä¼šè¯æ¨¡å—é—´ä¼ é€’äº‹ä»¶å’ŒæŒ‡ä»¤
â”‚   â”‚                            # åŠŸèƒ½: ç”±å·¥ä½œçº¿ç¨‹è°ƒç”¨, è·¯ç”±åˆ°SessionManageræˆ–å…·ä½“Session
â”‚   â”œâ”€â”€ session.h                # Sessionå¯¹è±¡å®šä¹‰
â”‚   â”‚   â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: SessionState (enum), ZK/TMSåª’ä½“ä¿¡æ¯,
â”‚   â”‚   â”‚                        #               ä¼šè¯ID, target_id, å¸¦å®½, Cué…ç½®å¼•ç”¨ç­‰
â”‚   â”‚   â”‚                        # ä¸»è¦å‡½æ•°: handleZkEvent(), handleTmsEvent(),
â”‚   â”‚   â”‚                        #           processMedia(), setupMediaRelayRules(),
â”‚   â”‚   â”‚                        #           initiateTmsCall(), sendStateToZk(), cleanup()
â”‚   â”œâ”€â”€ session.cpp              # Sessionå¯¹è±¡å®ç° (çŠ¶æ€æœº, æ ¸å¿ƒä¸šåŠ¡æµç¨‹)
â”‚   â”œâ”€â”€ session_manager.h        # SessionManagerç±»å®šä¹‰ (çº¿ç¨‹å®‰å…¨)
â”‚   â”‚   â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: std::unordered_map<SessionID, std::shared_ptr<Session>> active_sessions;
â”‚   â”‚   â”‚                        #               (å¯èƒ½è¿˜æœ‰å…¶ä»–ç´¢å¼•map, å¦‚ Port -> SessionID)
â”‚   â”‚   â”‚                        # ä¸»è¦å‡½æ•°: createSession(), findSession(), removeSession()
â”‚   â”œâ”€â”€ session_manager.cpp      # SessionManagerå®ç°
â”‚   â”œâ”€â”€ port_manager.h           # PortManagerç±»å®šä¹‰ (çº¿ç¨‹å®‰å…¨)
â”‚   â”‚   â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: std::set<uint16_t> available_ports; std::mutex mtx;
â”‚   â”‚   â”‚                        # ä¸»è¦å‡½æ•°: allocatePort(), releasePort()
â”‚   â”œâ”€â”€ port_manager.cpp         # PortManagerå®ç°
â”‚   â””â”€â”€ config_manager.h         # ConfigManagerç±»å®šä¹‰
â”‚       â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: Structs for ZK/TMS config, CU config table,
â”‚       â”‚                        #               CU-target_id map. (ä½¿ç”¨JSONåº“è§£æ)
â”‚       â”‚                        # ä¸»è¦å‡½æ•°: loadConfigs(), getZkConfig(zkId), getTmsConfig(),
â”‚       â”‚                        #           getCuConfig(cuId), getTargetCuMapping(targetId)
â”‚   â””â”€â”€ config_manager.cpp       # ConfigManagerå®ç°
â”‚
â”œâ”€â”€ media_processing/            # åª’ä½“å¤„ç†ä¸è½¬å‘
â”‚   â””â”€â”€ media_relay.{h,cpp}      # åª’ä½“ä¸­ç»§æ¨¡å— (çº¿ç¨‹å®‰å…¨)
â”‚       â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: ForwardingRule (åŒ…å«ç›®æ ‡IP/Port, åŒ…å¤´å¤„ç†å‡½æ•°æŒ‡é’ˆ/lambda, å‘é€Socketå¼•ç”¨)
â”‚       â”‚                        #               std::unordered_map<uint16_t /*local_rcv_port*/, ForwardingRule> zk_to_tms_flows;
â”‚       â”‚                        #               std::unordered_map<uint16_t /*local_rcv_port*/, ForwardingRule> tms_to_zk_flows;
â”‚       â”‚                        # ä¸»è¦å‡½æ•°: setupFlow(), teardownFlow(),
â”‚       â”‚                        #           processIncomingZkMedia(packet, local_port_or_session_id),
â”‚       â”‚                        #           processIncomingTmsMedia(packet, local_port)
â”‚
â””â”€â”€ logging/                     # æ—¥å¿—æ¨¡å—
    â””â”€â”€ logger_wrapper.{h,cpp}   # spdlogçš„å°è£…å’Œå…¨å±€è®¿é—®ç‚¹
```

---

### 5. å…³é”®æ•°æ®ç»“æ„ä¸å‡½æ•°æ¦‚è¿° (éƒ¨åˆ†å·²åœ¨ä¸Šé¢æåŠ)

- **`Session` å¯¹è±¡:**
    - **æ•°æ®:** `sessionId`, `zkId`, `targetId`, `bandwidth`, `zkAllocatedBridgeMediaPort` (ç”¨äºå‘å¾€ZK), `tmsAllocatedBridgeMediaPort` (ç”¨äºæ”¶å‘TMSåª’ä½“), `tmsRemoteMediaEndpoint`, `cuConfig`, `currentState (enum: IDLE, ZK_INITIATED, TMS_CONNECTING, ACTIVE, TERMINATING, ...)`ã€‚
    - **å‡½æ•°:** `handleZkSignaling(parsedMsg)`, `handleTmsSignaling(parsedMsg)`, `allocateMediaPorts()`, `setupMediaRelay()`, `sendToZkViaCoordinator(msg)`, `sendToTmsViaCoordinator(msg)`, `terminate()`.
- **`SessionManager`:**
    - **æ•°æ®:** `std::unordered_map<std::string /*SessionID*/, std::shared_ptr<Session>> sessions_by_id;` (ä¸»è¡¨ï¼Œçº¿ç¨‹å®‰å…¨), å¯èƒ½è¿˜æœ‰å…¶ä»–è¾…åŠ©ç´¢å¼•è¡¨å¦‚ `std::unordered_map<uint16_t /*BridgeLocalMediaPort*/, std::string /*SessionID*/> port_to_session_map;` (ç”¨äºåª’ä½“åŒ…åˆæ¬¡å…³è”ï¼Œä½†åç»­åª’ä½“è½¬å‘ä¸ä¾èµ–å®ƒ)ã€‚
    - **å‡½æ•°:** `createSessionFromZk(zkData)`, `getSessionById(id)`, `getSessionByLocalMediaPort(port)`, `removeSession(id)`.
- **`MediaRelay`:**
    - **æ•°æ®:** å¦‚ä¸Šæ‰€è¿°çš„ `active_flows_table` (ä¸¤ä¸ªæ–¹å‘çš„è½¬å‘è¡¨)ï¼Œé”®ä¸º Bridge æœ¬åœ°æ¥æ”¶åª’ä½“çš„ç«¯å£ï¼Œå€¼ä¸ºåŒ…å«å®Œæ•´è½¬å‘è·¯å¾„å’Œå¤„ç†è§„åˆ™çš„ç»“æ„ä½“ã€‚**è¿™äº›è¡¨å¿…é¡»æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚**
    - **å‡½æ•°:** `addFlow(sessionId, zkLocalPort, zkRemoteEp, tmsLocalPort, tmsRemoteEp, zkToTmsHeaderProc, tmsToZkHeaderProc)`, `removeFlow(sessionId_or_ports)`, `onUdpPacketReceived(buffer, len, localRecvPort, remoteSenderEp)`.
- **`ZkListener` (in `zk_interface`):**
    - **æ•°æ®:** `std::vector<std::unique_ptr<AsyncUDPSocket>> zk_listening_sockets;` (10ä¸ªï¼Œæ¯ä¸ªå¯¹åº”ä¸€ä¸ªZKçš„ä¿¡ä»¤/åª’ä½“å…¥å£)ã€‚
    - **å‡½æ•°:** `startListening()`, `onDataReceived(socket_idx, data, remote_ep)` (å›è°ƒï¼Œç”±æ­¤åˆ›å»ºä»»åŠ¡äº¤å·¥ä½œçº¿ç¨‹æ± )ã€‚

---

### 6. åº“çš„ä½¿ç”¨å»ºè®®

- **JSON åº“ (å¦‚ nlohmann/json for Modern C++):**
    - **ç”¨é€”:** åœ¨ `ConfigManager` ä¸­ç”¨äºè§£æ `.json` æ ¼å¼çš„é…ç½®æ–‡ä»¶ï¼ˆcué…ç½®è¡¨, cuå’Œtarget_idæ˜ å°„è¡¨, tms/zk ip portç­‰ï¼‰ã€‚
    - **é›†æˆ:** `ConfigManager` ä¾èµ–æ­¤åº“ã€‚
- **spdlog:**
    - **ç”¨é€”:** åœ¨æ•´ä¸ªåº”ç”¨ç¨‹åºä¸­æä¾›é«˜æ€§èƒ½çš„ã€å¯é…ç½®çš„æ—¥å¿—è®°å½•ã€‚
    - **é›†æˆ:** åˆ›å»ºä¸€ä¸ªå…¨å±€å¯è®¿é—®çš„ `LoggerWrapper` æˆ–ç›´æ¥åœ¨å„æ¨¡å—ä¸­ä½¿ç”¨ `spdlog` å®ä¾‹ã€‚æ—¥å¿—çº§åˆ«åº”å¯é…ç½®ã€‚
- **Redis (ç”¨äºä¸»å¤‡å®¹ç¾ - å¯é€‰çš„å¢å¼ºåŠŸèƒ½):**
    - **ç”¨é€”:**
        1. **ä¼šè¯çŠ¶æ€åŒæ­¥/æŒä¹…åŒ–:** å½“ `Session` å¯¹è±¡çš„çŠ¶æ€å‘ç”Ÿå…³é”®å˜åŒ–ï¼ˆåˆ›å»ºã€æ¿€æ´»ã€åª’ä½“ä¿¡æ¯æ›´æ–°ã€æ‹†é™¤ï¼‰æ—¶ï¼Œå¯ä»¥å°†è¿™äº›çŠ¶æ€å¼‚æ­¥åœ°å†™å…¥ Redisã€‚
        2. **ä¸»å¤‡åˆ‡æ¢:** å¦‚æœä¸» Bridge å®ä¾‹æ•…éšœï¼Œå¤‡ç”¨ Bridge å®ä¾‹å¯åŠ¨åå¯ä»¥ä» Redis è¯»å–æ´»åŠ¨çš„ä¼šè¯ä¿¡æ¯ï¼Œå°è¯•æ¢å¤ä¼šè¯ï¼ˆä¾‹å¦‚ï¼Œé‡æ–°å»ºç«‹åª’ä½“è·¯å¾„ï¼Œæˆ–è‡³å°‘çŸ¥é“å“ªäº›ä¼šè¯å­˜åœ¨è¿‡ä»¥ä¾¿è¿›è¡Œæ¸…ç†æˆ–é€šçŸ¥ï¼‰ã€‚
        3. **åˆ†å¸ƒå¼é”/é¢†å¯¼è€…é€‰ä¸¾ (å¯é€‰):** å¦‚æœæœ‰å¤šä¸ªActiveçš„Bridgeå®ä¾‹ï¼ˆæ›´å¤æ‚çš„è´Ÿè½½å‡è¡¡åœºæ™¯ï¼‰ï¼Œæˆ–è€…ä¸¥æ ¼çš„ä¸»å¤‡åˆ‡æ¢ï¼Œå¯èƒ½éœ€è¦ã€‚
        4. **(å¯é€‰) åˆ†å¸ƒå¼ç«¯å£ç®¡ç†:** å¦‚æœå¤šä¸ªBridgeå®ä¾‹éœ€è¦ä»ä¸€ä¸ªå…¨å±€å”¯ä¸€çš„ç«¯å£æ± ä¸­åˆ†é…ç«¯å£ã€‚
    - **é›†æˆ:**
        - `SessionManager` æˆ– `Session` å¯¹è±¡åœ¨çŠ¶æ€å˜æ›´æ—¶ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªä»»åŠ¡ï¼ˆæˆ–ç›´æ¥è°ƒç”¨ï¼‰ä¸ Redis äº¤äº’çš„æ¨¡å—ã€‚
        - éœ€è¦ä¸€ä¸ª `RedisClient` æˆ– `RedisInterface` æ¨¡å—æ¥å°è£…ä¸ Redis æœåŠ¡å™¨çš„é€šä¿¡ (å¯ä»¥ä½¿ç”¨å¦‚ `redis-plus-plus` æˆ– `hiredis` C/C++ å®¢æˆ·ç«¯åº“)ã€‚
        - **è€ƒè™‘ç‚¹:**
            - å†™å…¥ Redis çš„é¢‘ç‡å’Œæ•°æ®é‡ï¼ˆé¿å…æˆä¸ºç“¶é¢ˆï¼‰ã€‚
            - æ•°æ®ä¸€è‡´æ€§ä¸åºåˆ—åŒ–/ååºåˆ—åŒ–ã€‚
            - Redis çš„éƒ¨ç½²å’Œå¯ç”¨æ€§ã€‚
            - ä¼šè¯æ¢å¤çš„å¤æ‚æ€§ï¼ˆé‡æ–°å»ºç«‹ UDP åª’ä½“æµé€šå¸¸æ¯” TCP è¿æ¥æ¢å¤æ›´å¤æ‚ï¼Œå› ä¸ºUDPæ— çŠ¶æ€ï¼‰ã€‚å¯¹äºåª’ä½“ï¼Œå¯èƒ½æ›´å¤šçš„æ˜¯çŸ¥é“ä¼šè¯å­˜åœ¨ï¼Œç„¶åå°è¯•å¿«é€Ÿæ‹†é™¤æˆ–æŒ‡ç¤ºå¯¹ç«¯é‡å»ºã€‚

---

è¿™ä¸ªç»“æ„è®¾è®¡è€ƒè™‘äº†æ‚¨æœ€æ–°çš„éœ€æ±‚å’Œæˆ‘ä»¬ä¹‹å‰çš„è®¨è®ºï¼Œæ—¨åœ¨æä¾›ä¸€ä¸ªæ¸…æ™°ã€é«˜æ•ˆä¸”å¯æ‰©å±•çš„ C++ Bridge ç³»ç»Ÿè“å›¾ã€‚å®é™…å®ç°æ—¶ï¼Œè¿˜éœ€è¦åœ¨å¼‚æ­¥ç¼–ç¨‹ã€é”™è¯¯å¤„ç†ã€çº¿ç¨‹åŒæ­¥ç»†èŠ‚ä¸Šè¿›è¡Œç»†è‡´çš„å·¥ä½œã€‚




å¥½çš„ï¼Œæˆ‘ä»¬æ¥åŸºäºä¹‹å‰çš„è®¨è®ºï¼Œå¼€å§‹æ•´ç†ä¸€ä»½æ›´è¯¦ç»†çš„è®¾è®¡æ–‡æ¡£ã€‚æˆ‘ä»¬å°†ä»æ‚¨æœ€å…³æ³¨çš„ `protocols/zk_protocol/` æ¨¡å—å¼€å§‹ï¼Œç„¶åé€æ­¥æ‰©å±•åˆ°å…¶ä»–æ¨¡å—ä¸å®ƒäº¤äº’çš„éƒ¨åˆ†ï¼Œä»¥åŠå…¶ä»–æ¨¡å—è‡ªèº«çš„ä¸€äº›å…³é”®è®¾è®¡ç‚¹ã€‚

è¿™ä¸ªè¿‡ç¨‹æˆ‘ä¼šå°½é‡ç»†åŒ–ï¼Œä½†è¯·è®°ä½ï¼ŒçœŸæ­£çš„è¯¦ç»†è®¾è®¡æ˜¯ä¸€ä¸ªéå¸¸ç»†è‡´çš„å·¥ä½œï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œä¸»è¦æ˜¯æ„å»ºä¸€ä¸ªæ¸…æ™°çš„æ¡†æ¶å’Œå…³é”®è¦ç´ ã€‚

---

## Bridge ç³»ç»Ÿè¯¦ç»†è®¾è®¡ (è‰æ¡ˆ V1)

**æ–‡æ¡£ç›®æ ‡ï¼š** æ˜ç¡®å„æ¨¡å—çš„æ ¸å¿ƒèŒè´£ã€æ¥å£ã€å…³é”®æ•°æ®ç»“æ„å’Œäº¤äº’æ–¹å¼ï¼Œä¸ºåç»­ç¼–ç å®ç°æä¾›æŒ‡å¯¼ã€‚æœ¬è®¾è®¡åŸºäºI/Oå¤ç”¨ã€äº‹ä»¶é©±åŠ¨å’Œå¤šçº¿ç¨‹ï¼ˆI/Oçº¿ç¨‹ + å·¥ä½œçº¿ç¨‹æ± ï¼‰çš„æ¶æ„æ¨¡å‹ã€‚

---

### **ç¬¬ä¸€éƒ¨åˆ†ï¼šåè®®å±‚ (Protocol Layer)**

#### **æ¨¡å— 1.1: `protocols/zk_protocol/` - ZK åè®®å¤„ç†æ¨¡å—**

1. æ¦‚è¿° (Overview):

å®šä¹‰Bridgeä¸ZKå®ä½“é—´é€šä¿¡åè®®çš„æ¶ˆæ¯æ•°æ®ç»“æ„ï¼Œå¹¶æä¾›å°†åŸå§‹å­—èŠ‚æµä¸è¿™äº›ç»“æ„ä½“ç›¸äº’è½¬æ¢ï¼ˆç¼–ç /è§£ç ï¼‰çš„çº¯åŠŸèƒ½æ€§æ–¹æ³•ã€‚æœ¬æ¨¡å—ä¸å¤„ç†ç½‘ç»œI/Oï¼Œä¹Ÿä¸åŒ…å«UDPä¹‹ä¸Šçš„è‡ªå®šä¹‰å¯é ä¼ è¾“é€»è¾‘ï¼ˆå¦‚é‡ä¼ ã€ACKçŠ¶æ€ç®¡ç†ï¼‰ã€‚

**2. ä¸»è¦èŒè´£ (Key Responsibilities):**

- å®šä¹‰æ‰€æœ‰ZKä¸Šä¸‹è¡Œåè®®æ¶ˆæ¯çš„C++æ•°æ®ç»“æ„/ç±»ï¼ŒåŒ…æ‹¬å…¬å…±å¤´éƒ¨å’Œç‰¹å®šæ¶ˆæ¯çš„è½½è·ã€‚
- æä¾›è§£ç ï¼ˆè§£æï¼‰åŠŸèƒ½ï¼šå°†æ¥æ”¶åˆ°çš„åŸå§‹ZK UDPæ•°æ®åŒ…å­—èŠ‚æµï¼Œæ ¹æ®å…¬å…±å¤´éƒ¨ä¸­çš„ç‰¹å®šå­—æ®µï¼ˆå¦‚æ¶ˆæ¯ç±»å‹ã€ä¿¡æ¯å•å…ƒç±»å‹ï¼‰è¯†åˆ«æ¶ˆæ¯ï¼Œå¹¶è½¬æ¢ä¸ºå¯¹åº”çš„C++æ¶ˆæ¯ç»“æ„ä½“ã€‚æ”¯æŒè§£æåŒ…å«å¤šä¸ªâ€œä¿¡æ¯å•å…ƒâ€çš„å¤åˆæ¶ˆæ¯ã€‚
- æä¾›ç¼–ç ï¼ˆæ ¼å¼åŒ–ï¼‰åŠŸèƒ½ï¼šå°†å†…éƒ¨C++æ¶ˆæ¯ç»“æ„ä½“åºåˆ—åŒ–ä¸ºå¾…å‘é€çš„UDPå­—èŠ‚æµã€‚
- å¤„ç†åè®®å­—æ®µçš„å­—èŠ‚åºè½¬æ¢ï¼ˆç½‘ç»œå­—èŠ‚åº &lt;-> ä¸»æœºå­—èŠ‚åºï¼‰ã€‚

**3. ä¸»è¦è¾“å…¥ (Key Inputs to its functions):**

- è§£ç å‡½æ•°è¾“å…¥: `const unsigned char* buffer`, `size_t length` (åŸå§‹å­—èŠ‚æµåŠå…¶é•¿åº¦)ã€‚
- ç¼–ç å‡½æ•°è¾“å…¥: `const SpecificZkMessage& message_struct` (å¾…ç¼–ç çš„C++æ¶ˆæ¯ç»“æ„ä½“å¯¹è±¡)ã€‚

**4. ä¸»è¦è¾“å‡º (Key Outputs from its functions):**

- è§£ç å‡½æ•°è¾“å‡º: `std::optional<ParsedZkMessageVariant>` (åŒ…å«è§£æåçš„C++æ¶ˆæ¯ç»“æ„ä½“ï¼Œæˆ–åœ¨å¤±è´¥æ—¶ä¸ºç©º) æˆ–åŒ…å«é”™è¯¯ç çš„ç‰¹å®šç»“æœç±»å‹ã€‚
- ç¼–ç å‡½æ•°è¾“å‡º: `std::vector<unsigned char>` (åŒ…å«åºåˆ—åŒ–åçš„å­—èŠ‚æµ) æˆ–é”™è¯¯ç ã€‚

**5. ä¾èµ–çš„å…¶ä»–æ¨¡å— (Dependencies):**

- C++æ ‡å‡†åº“ (å¦‚ `<vector>`, `<string>`, `<cstdint>`, `<variant>`, `<optional>`, `<algorithm>`)ã€‚
- å­—èŠ‚åºè½¬æ¢å‡½æ•° (å¦‚ç³»ç»Ÿæä¾›çš„ `htons`, `ntohl` ç­‰ï¼Œé€šå¸¸åœ¨ `<arpa/inet.h>` æˆ–ç”± `common/utils/endian_converter.h` å°è£…)ã€‚

**6. è¢«å“ªäº›æ¨¡å—ä¾èµ– (Depended On By):**

- `interfaces/zk_interface/` (ä¸»è¦ä½¿ç”¨è€…ï¼Œè°ƒç”¨æœ¬æ¨¡å—çš„ç¼–è§£ç å‡½æ•°)ã€‚

**7. æ ¸å¿ƒå¯¹å¤–æ¥å£ (Key Public APIs - åˆæ­¥è®¾æƒ³):**

- **`zk_message_types.h`**:
    
    C++
    
    ```
    #include <cstdint>
    #include <string>
    #include <vector>
    #include <variant>
    #include <optional>
    
    namespace ZkProtocol {
    
    // --- æšä¸¾å®šä¹‰ ---
    enum class MessageType : uint16_t { // å‡è®¾åœ¨å…¬å…±å¤´éƒ¨ä¸­å®šä¹‰
        INITIATE_CALL_REQUEST = 0x0001,
        INITIATE_CALL_RESPONSE = 0x0002,
        CALL_DISCONNECT_REQUEST = 0x0003,
        CALL_DISCONNECT_RESPONSE = 0x0004,
        HEARTBEAT_REQUEST = 0x0005,
        HEARTBEAT_RESPONSE = 0x0006,
        MEDIA_DATA_FORWARD = 0x0100, // ç”¨äºåª’ä½“æ•°æ®åŒ…ï¼Œç”±MediaRelayè°ƒç”¨
        // ... å…¶ä»–ä¿¡ä»¤æ¶ˆæ¯ç±»å‹
        UNKNOWN = 0xFFFF
    };
    
    enum class ReliabilityFlags : uint8_t {
        NONE = 0x00,
        ACK_REQUESTED = 0x01,
        IS_ACK = 0x02,
        // ... å…¶ä»–å¯é æ€§ç›¸å…³çš„æ ‡å¿—
    };
    
    // --- å…¬å…±æ¶ˆæ¯å¤´ ---
    struct CommonHeader {
        uint32_t sequence_number;    // åºåˆ—å· (ç”¨äºå¯é æ€§å±‚)
        uint32_t ack_number;         // ç¡®è®¤å· (ç”¨äºå¯é æ€§å±‚)
        ReliabilityFlags flags;       // æ ‡å¿—ä½ (ç”¨äºå¯é æ€§å±‚)
        MessageType message_type;    // æ¶ˆæ¯ç±»å‹ (ç”¨äºåˆ†å‘åˆ°å…·ä½“æ¶ˆæ¯è§£æ)
        uint16_t total_length;       // æ•´ä¸ªæ¶ˆæ¯çš„æ€»é•¿åº¦ (åŒ…æ‹¬å¤´éƒ¨å’Œè½½è·)
        // ... å…¶ä»–é€šç”¨å¤´éƒ¨å­—æ®µï¼Œå¦‚ç‰ˆæœ¬å·ï¼Œæº/ç›®æ ‡å®ä½“IDï¼ˆå¦‚æœåè®®æœ‰è§„å®šï¼‰
    };
    constexpr size_t COMMON_HEADER_SIZE = sizeof(CommonHeader); // æ³¨æ„å¯¹é½å’Œå®é™…æ‰“åŒ…å¤§å°
    
    // --- ç‰¹å®šä¿¡ä»¤æ¶ˆæ¯ç»“æ„ä½“ ---
    struct InitiateCallRequest {
        std::string target_id;       // è¢«å«å·ç 
        uint32_t bandwidth_kbps;    // å¸¦å®½éœ€æ±‚
        // ... å…¶ä»–ç‰¹å®šå­—æ®µ
    };
    
    struct InitiateCallResponse {
        bool success;
        std::string zk_session_id;   // ZKä¾§ä¼šè¯æ ‡è¯†
        uint16_t bridge_media_port_for_zk; // Bridgeåˆ†é…ç»™ZKç”¨äºå‘é€åª’ä½“çš„ç«¯å£ (Bridgeæ¥æ”¶ZKåª’ä½“)
                                           // **æ›´æ­£: æ­¤å¤„åº”ä¸ºBridgeåˆ†é…ç”¨äºä»ZKæ¥æ”¶åª’ä½“çš„ç«¯å£ï¼Œ
                                           //  æˆ–ZKå‘ŠçŸ¥Bridgeå®ƒå°†ç”¨äºå‘é€åª’ä½“çš„ç«¯å£ï¼Œå…·ä½“çœ‹åè®®è®¾è®¡ã€‚
                                           //  å‡è®¾æ­¤å¤„æ˜¯Bridgeå‘ŠçŸ¥ZKï¼šâ€œä½ çš„åª’ä½“è¯·å‘å¾€æˆ‘çš„è¿™ä¸ªç«¯å£Xâ€
                                           //  æˆ–è€…ï¼Œå¦‚æœæ˜¯ZKå…ˆæŒ‡å®šï¼Œé‚£è¿™é‡Œæ˜¯ZKçš„ç«¯å£ã€‚
                                           //  æ ¹æ®ç”¨æˆ·æè¿° "zkå§‹ç»ˆç”¨ä¸€ä¸ªç«¯å£æ¥æ¥æ”¶200è·¯çš„ä¸šåŠ¡æ¶ˆæ¯ï¼Œ
                                           //  å› ä¸ºå‘é€ç»™zkæ¶ˆæ¯æ—¶ä¼šé€šè¿‡ä¸€ä¸ªå­—æ®µæ¥åŒºåˆ†ä¸åŒçš„sessionä¸šåŠ¡"
                                           //  ä»¥åŠ "bridgeå¯¹äºæ¯ä¸ªzkæœ‰ä¸€ä¸ªä¿¡ä»¤ç«¯å£å’Œä¸€è·¯ä¼šè¯å°±ä¸€ä¸ªä¸šåŠ¡ç«¯å£ï¼ˆå‘zkå‘é€çš„ï¼‰"
                                           //  è¿™æš—ç¤ºBridgeåˆ†é…ä¸€ä¸ªç«¯å£ç”¨äº *æ¥æ”¶* ZKç‰¹å®šä¼šè¯çš„åª’ä½“ï¼Œ
                                           //  æˆ–è€…ZKå‘å¾€Bridgeçš„å…±äº«ä¿¡ä»¤/åª’ä½“ç«¯å£åï¼ŒBridgeé€šè¿‡åŒ…å†…å­—æ®µåŒºåˆ†ã€‚
                                           //  æ­¤å¤„æˆ‘ä»¬å‡è®¾æ˜¯Bridgeåˆ†é…ç”¨äº*æ¥æ”¶*ZKåª’ä½“çš„ç«¯å£ã€‚
                                           //  ä½†ç”¨æˆ·æœ€æ–°æè¿°æ˜¯ZKæ‰€æœ‰ä¸šåŠ¡éƒ½ä»ä¸€ä¸ªç«¯å£å‘å‡ºåˆ°Bridgeçš„å¯¹åº”ZKä¿¡ä»¤ç«¯å£ã€‚
                                           //  æ‰€ä»¥æ­¤å­—æ®µå¯èƒ½ä¸éœ€è¦ï¼Œæˆ–è¡¨ç¤ºå…¶ä»–å«ä¹‰ã€‚
                                           //  **æš‚æ—¶ä»¥æ­¤ä¸ºBridgeåˆ†é…ç”¨äºæ¥æ”¶ZKåª’ä½“çš„ç«¯å£ï¼Œå¦‚æœZKä¼šç”¨ä¸åŒç«¯å£å‘åª’ä½“çš„è¯ã€‚
                                           //  å¦‚æœZKæ‰€æœ‰åª’ä½“éƒ½å‘å¾€Bridgeçš„ZKä¿¡ä»¤ç«¯å£ï¼Œåˆ™æ­¤å­—æ®µæ— ç›´æ¥å¯¹åº”ã€‚**
    
                                           // **æ ¹æ®æœ€æ–°ç†è§£ï¼ŒZKæ‰€æœ‰ä¸œè¥¿éƒ½å‘ç»™Bridgeçš„ZKä¿¡ä»¤/åª’ä½“ç»Ÿä¸€å…¥å£ã€‚
                                           // æ­¤å¤„å¯èƒ½ä¸ºBridgeåˆ†é…ç”¨äº *å‘ZKå‘é€åª’ä½“* çš„æœ¬åœ°æºç«¯å£ (ZKä¼šçœ‹åˆ°æ¥è‡ªæ­¤ç«¯å£çš„åª’ä½“)**
        std::string error_message;
    };
    
    // ... å…¶ä»–ä¿¡ä»¤æ¶ˆæ¯çš„ç»“æ„ä½“ ...
    
    
    // --- ç”¨äºåª’ä½“è½¬å‘çš„ç‰¹å®šç»“æ„ (ç”±MediaRelayè°ƒç”¨æœ¬æ¨¡å—çš„ç¼–ç å‡½æ•°) ---
    // è¿™ä¸ªç»“æ„å¯èƒ½ä¸æ˜¯ç›´æ¥é€šè¿‡ç½‘ç»œå‘é€çš„â€œæ¶ˆæ¯ç±»å‹â€ï¼Œè€Œæ˜¯MediaRelayéœ€è¦å°è£…çš„æ•°æ®
    struct MediaPacketToZk {
        CommonHeader common_zk_header; // ZKåè®®çš„å…¬å…±å¤´éƒ¨ (åºåˆ—å·ç­‰ç”±å¯é æ€§å±‚å¡«å……)
        // è¿™é‡Œæ˜¯çº¯åª’ä½“è´Ÿè½½ï¼Œå®é™…çš„â€œåŠ åŒ…å¤´â€å°±æ˜¯å¡«å……ä¸Šé¢çš„CommonHeader
        // å¹¶ç¡®ä¿æ•´ä¸ªåŒ…ç¬¦åˆZKåè®®å¯¹åª’ä½“æ•°æ®åŒ…çš„å®šä¹‰
    };
    
    
    // --- è§£æç»“æœçš„Variant ---
    using ParsedZkMessagePayload = std::variant<
        std::monostate, // è¡¨ç¤ºç©ºæˆ–æœªçŸ¥ï¼Œæˆ–åªæœ‰å…¬å…±å¤´éƒ¨
        InitiateCallRequest,
        InitiateCallResponse
        // ... å…¶ä»–ç‰¹å®šä¿¡ä»¤æ¶ˆæ¯çš„è½½è·ç»“æ„ä½“
    >;
    
    struct DecodedZkMessage {
        CommonHeader header;
        ParsedZkMessagePayload payload;
        // å¯ä»¥åŠ å…¥æ¥æºZKçš„æ ‡è¯†ï¼Œå¦‚æœé¡¶å±‚è§£æå‡½æ•°èƒ½è·å–åˆ°
    };
    
    
    } // namespace ZkProtocol
    ```
    
- **`zk_parser.h`**:
    
    C++
    
    ```
    #include "zk_message_types.h"
    #include <optional>
    
    namespace ZkProtocol::Parser {
    
    // é¡¶å±‚è§£æå‡½æ•°ï¼Œè´Ÿè´£è¯†åˆ«æ¶ˆæ¯ç±»å‹å¹¶åˆ†å‘
    std::optional<DecodedZkMessage> decode_packet(const unsigned char* buffer, size_t len);
    
    // (ä»¥ä¸‹å¯èƒ½æ˜¯å†…éƒ¨è¾…åŠ©å‡½æ•°ï¼Œæˆ–æ ¹æ®éœ€è¦æš´éœ²)
    // ZkMessageType get_message_type_from_header(const CommonHeader& header);
    // std::optional<InitiateCallRequest> decode_initiate_call_request_payload(const unsigned char* payload_buffer, size_t payload_len);
    // ... å…¶ä»–ç‰¹å®šæ¶ˆæ¯è½½è·çš„è§£ç å‡½æ•° ...
    
    } // namespace ZkProtocol::Parser
    ```
    
- **`zk_formatter.h`**:
    
    C++
    
    ```
    #include "zk_message_types.h"
    #include <vector>
    
    namespace ZkProtocol::Formatter {
    
    // é¡¶å±‚ç¼–ç å‡½æ•° (æ ¹æ®ä¼ å…¥çš„ç»“æ„ä½“ç±»å‹)
    std::vector<unsigned char> encode_message(const DecodedZkMessage& message); // æˆ–è€…ä¸ºæ¯ç§æ¶ˆæ¯æä¾›å•ç‹¬çš„encodeå‡½æ•°
    
    // (ä»¥ä¸‹å¯èƒ½æ˜¯å†…éƒ¨è¾…åŠ©å‡½æ•°ï¼Œæˆ–æ ¹æ®éœ€è¦æš´éœ²)
    // std::vector<unsigned char> encode_initiate_call_request(const CommonHeader& header, const InitiateCallRequest& payload);
    // ... å…¶ä»–ç‰¹å®šæ¶ˆæ¯çš„ç¼–ç å‡½æ•° ...
    
    // ç‰¹åˆ«ä¸ºMediaRelayæä¾›çš„ï¼Œç”¨äºå°è£…è£¸åª’ä½“æ•°æ®ä¸ºZKåª’ä½“åŒ…
    // header_template åº”åŒ…å«é™¤åºåˆ—å·ç­‰åŠ¨æ€å­—æ®µå¤–çš„å¤´éƒ¨ä¿¡æ¯
    // reliability_handler (åœ¨zk_interfaceä¸­) ä¼šåœ¨å‘é€å‰å¡«å†™æœ€ç»ˆçš„åºåˆ—å·ç­‰
    std::vector<unsigned char> encode_media_packet_for_zk(
        const CommonHeader& header_template, // å¯é æ€§å­—æ®µç”±è°ƒç”¨æ–¹ï¼ˆzk_interfaceçš„å¯é æ€§æ¨¡å—ï¼‰å¡«å……
        const unsigned char* media_payload,
        size_t media_payload_len
    );
    
    } // namespace ZkProtocol::Formatter
    ```
    

**8. å…³é”®å†…éƒ¨æ•°æ®ç»“æ„ (Key Internal Data Structures - åˆæ­¥è®¾æƒ³):**

- ä¸»è¦æ˜¯ä¸Šè¿° `zk_message_types.h` ä¸­å®šä¹‰çš„å„ç§æ¶ˆæ¯ç»“æ„ä½“ã€‚
- è§£æå‡½æ•°å†…éƒ¨å¯èƒ½ä½¿ç”¨ä¸´æ—¶çš„ã€åŸºäºçŠ¶æ€çš„è§£æå™¨ä¸Šä¸‹æ–‡ç»“æ„ï¼Œä½†è¿™äº›ä¸å…¬å¼€ã€‚

**9. éåŠŸèƒ½æ€§éœ€æ±‚è€ƒé‡ (NFRs):**

- **æ€§èƒ½:** ç¼–è§£ç æ“ä½œå¿…é¡»éå¸¸é«˜æ•ˆï¼Œé¿å…ä¸å¿…è¦çš„å†…å­˜æ‹·è´ã€‚
- **å¥å£®æ€§:** èƒ½å¤Ÿä¼˜é›…å¤„ç†æ ¼å¼é”™è¯¯ã€ä¸å®Œæ•´çš„æ•°æ®åŒ…ï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡è¿”å› `std::nullopt` æˆ–ç‰¹å®šçš„é”™è¯¯å¯¹è±¡ï¼‰ï¼Œå¹¶æä¾›è¶³å¤Ÿçš„é”™è¯¯ä¿¡æ¯ä¾›ä¸Šå±‚æ¨¡å—è®°å½•å’Œå¤„ç†ã€‚
- **æ­£ç¡®æ€§:** ä¸¥æ ¼æŒ‰ç…§ZKåè®®è§„èŒƒè¿›è¡Œç¼–è§£ç ï¼Œç‰¹åˆ«æ˜¯å­—èŠ‚åºã€å­—æ®µé•¿åº¦å’Œå¯¹é½ã€‚
- **å¯æµ‹è¯•æ€§:** å®¹æ˜“ä¸ºå„ç§æ¶ˆæ¯ç±»å‹å’Œè¾¹ç•Œæ¡ä»¶ç¼–å†™å•å…ƒæµ‹è¯•ã€‚

**10. å¾…è®¨è®º/æœªæ˜ç¡®ç‚¹ (Open Questions):**

- ZKåè®®æ˜¯å¦æœ‰å®˜æ–¹çš„ã€å­—èŠ‚çº§çš„è¯¦ç»†å®šä¹‰æ–‡æ¡£ï¼Ÿï¼ˆéå¸¸é‡è¦ï¼ï¼‰
- `CommonHeader` ä¸­çš„ `message_type` å­—æ®µæ˜¯å¦‚ä½•ç¡®å®šçš„ï¼Ÿå®ƒæ˜¯å¦è¶³ä»¥åŒºåˆ†æ‰€æœ‰é¡¶å±‚æ¶ˆæ¯ï¼Ÿ
- å¦‚æœæ¶ˆæ¯ä½“åŒ…å«â€œä¿¡æ¯å•å…ƒä¸ªæ•°â€å’Œå¤šä¸ªå¯å˜ç±»å‹/é•¿åº¦çš„â€œä¿¡æ¯å•å…ƒâ€ï¼Œ`decode_packet` å’Œç›¸å…³è½½è·è§£ç å‡½æ•°éœ€è¦å®ç°å¾ªç¯è§£æé€»è¾‘ã€‚
- é”™è¯¯å¤„ç†æœºåˆ¶ï¼šè§£æå¤±è´¥æ—¶ï¼Œæ˜¯è¿”å› `std::nullopt`ï¼Œè¿˜æ˜¯ä¸€ä¸ªåŒ…å«é”™è¯¯ç å’Œæè¿°çš„ `Result` ç±»å‹å¯¹è±¡ï¼Ÿ
- å­—èŠ‚åºï¼šæ˜ç¡®åè®®æ‰€æœ‰å¤šå­—èŠ‚å­—æ®µçš„å­—èŠ‚åºï¼ˆåº”ä¸ºç½‘ç»œå­—èŠ‚åºï¼‰ï¼Œå¹¶åœ¨ç¼–è§£ç æ—¶å¤„ç†ã€‚

---

#### **æ¨¡å— 1.2: `protocols/tms_protocol/` - TMS åè®®å¤„ç†æ¨¡å—**

- (è®¾è®¡æ€è·¯å’Œç»“æ„ä¸ `protocols/zk_protocol/` éå¸¸ç›¸ä¼¼ï¼Œåªæ˜¯é’ˆå¯¹TMSçš„åè®®è§„èŒƒè¿›è¡Œå®šä¹‰å’Œå®ç°)
- éœ€è¦æ˜ç¡®TMSä¿¡ä»¤æ˜¯é€šè¿‡TCPè¿˜æ˜¯UDPï¼Œä»¥åŠå…¶æ¶ˆæ¯æ ¼å¼ã€‚

---

### **ç¬¬äºŒéƒ¨åˆ†ï¼šé€šç”¨åŸºç¡€æ¨¡å— (Common Infrastructure)**

#### **æ¨¡å— 2.1: `common/communication/` - é€šä¿¡å±‚**

1. æ¦‚è¿° (Overview):

æä¾›åº•å±‚çš„ã€å¼‚æ­¥çš„ç½‘ç»œSocketæ“ä½œå°è£…ï¼Œä¸å…·ä½“çš„ZKæˆ–TMSåè®®æ— å…³ã€‚ä¸I/Oå¤ç”¨æœºåˆ¶ï¼ˆå¦‚epollï¼‰é›†æˆã€‚

**2. ä¸»è¦èŒè´£ (Key Responsibilities):**

- å°è£…å¼‚æ­¥UDP Socketçš„åˆ›å»ºã€ç»‘å®šã€æ•°æ®æ”¶å‘ (`async_udp_socket.{h,cpp}`)ã€‚
- å°è£…å¼‚æ­¥TCPå®¢æˆ·ç«¯Socketçš„åˆ›å»ºã€è¿æ¥ã€æ•°æ®æ”¶å‘ã€æ–­å¼€ (`async_tcp_client.{h,cpp}`) (ç”¨äºè¿æ¥TMSä¿¡ä»¤)ã€‚
- ï¼ˆå¯é€‰ï¼‰å°è£…å¼‚æ­¥TCPæœåŠ¡å™¨Socketçš„åˆ›å»ºã€ç›‘å¬ã€æ¥å—è¿æ¥ (`async_tcp_server.{h,cpp}`) (å¦‚æœBridgeéœ€è¦å¯¹å¤–æä¾›TCPç®¡ç†æ¥å£)ã€‚
- æ‰€æœ‰æ“ä½œéƒ½åº”è®¾è®¡ä¸ºéé˜»å¡çš„ï¼Œå¹¶èƒ½ä¸å¤–éƒ¨çš„äº‹ä»¶å¾ªç¯ï¼ˆå¦‚epollï¼‰é›†æˆï¼ˆä¾‹å¦‚ï¼Œé€šè¿‡å›è°ƒå‡½æ•°ã€`std::future` æˆ–å…¶ä»–å¼‚æ­¥é€šçŸ¥æœºåˆ¶ï¼‰ã€‚

**3. æ ¸å¿ƒå¯¹å¤–æ¥å£ (Key Public APIs - åˆæ­¥è®¾æƒ³):**

- `AsyncUDPSocket::bind(ip, port)`
- `AsyncUDPSocket::async_receive_from(buffer, callback_on_received)`
- `AsyncUDPSocket::async_send_to(buffer, target_ip, target_port, callback_on_sent)`
- `AsyncTCPClient::async_connect(ip, port, callback_on_connected)`
- `AsyncTCPClient::async_send(buffer, callback_on_sent)`
- `AsyncTCPClient::async_receive(buffer, callback_on_received)`
- `AsyncTCPClient::close()`

**4. ä¾èµ–çš„å…¶ä»–æ¨¡å— (Dependencies):**

- æ“ä½œç³»ç»ŸSocket API (`<sys/socket.h>`, `<netinet/in.h>`, `<arpa/inet.h>`ç­‰ï¼Œæˆ–Boost.Asioç­‰ç½‘ç»œåº“)ã€‚
- I/Oå¤ç”¨æœºåˆ¶çš„å°è£… (å¯èƒ½åœ¨å†…éƒ¨å®ç°ï¼Œæˆ–ä¾èµ–å¤–éƒ¨äº‹ä»¶å¾ªç¯)ã€‚

**5. è¢«å“ªäº›æ¨¡å—ä¾èµ– (Depended On By):**

- `interfaces/zk_interface/`
- `interfaces/tms_interface/`

#### **æ¨¡å— 2.2: `common/task_queue/` - çº¿ç¨‹å®‰å…¨ä»»åŠ¡é˜Ÿåˆ—**

1. æ¦‚è¿° (Overview):

æä¾›ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„é˜Ÿåˆ—ï¼Œç”¨äºI/Oçº¿ç¨‹å‘å·¥ä½œçº¿ç¨‹æ± åˆ†å‘å¤„ç†ä»»åŠ¡ã€‚

**2. ä¸»è¦èŒè´£ (Key Responsibilities):**

- å®ç°çº¿ç¨‹å®‰å…¨çš„å…¥é˜Ÿ (`push`) å’Œå‡ºé˜Ÿ (`pop`/`try_pop`) æ“ä½œã€‚
- æ”¯æŒé˜»å¡ç­‰å¾…ï¼ˆå½“é˜Ÿåˆ—ä¸ºç©ºæ—¶ï¼Œå·¥ä½œçº¿ç¨‹å¯ä»¥ç­‰å¾…ï¼‰å’Œå”¤é†’æœºåˆ¶ã€‚

**3. æ ¸å¿ƒå¯¹å¤–æ¥å£ (Key Public APIs - åˆæ­¥è®¾æƒ³):**

C++

```
template<typename T> // T æ˜¯ä»»åŠ¡å¯¹è±¡çš„ç±»å‹
class ConcurrentQueue {
public:
    void push(T task);
    bool try_pop(T& out_task);
    T wait_and_pop(); // é˜»å¡ç›´åˆ°æœ‰ä»»åŠ¡
    // ...
};
```

- ä»»åŠ¡å¯¹è±¡ `T` å¯ä»¥æ˜¯ä¸€ä¸ª `std::function<void()>`ï¼Œæˆ–è€…ä¸€ä¸ªåŒ…å«å¤„ç†æ‰€éœ€æ•°æ®çš„è‡ªå®šä¹‰ç»“æ„ä½“ã€‚

**4. ä¾èµ–çš„å…¶ä»–æ¨¡å— (Dependencies):**

- C++æ ‡å‡†åº“ (`<queue>`, `<mutex>`, `<condition_variable>`)ã€‚

**5. è¢«å“ªäº›æ¨¡å—ä¾èµ– (Depended On By):**

- I/Oçº¿ç¨‹ (ç”Ÿäº§è€…)
- å·¥ä½œçº¿ç¨‹æ±  (æ¶ˆè´¹è€…)

#### **æ¨¡å— 2.3: `logging/` - æ—¥å¿—æ¨¡å—**

1. æ¦‚è¿° (Overview):

æä¾›å…¨å±€çš„ã€å¯é…ç½®çš„ã€é«˜æ€§èƒ½çš„æ—¥å¿—è®°å½•åŠŸèƒ½ã€‚æ¨èä½¿ç”¨ spdlogã€‚

**2. ä¸»è¦èŒè´£ (Key Responsibilities):**

- åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿï¼ˆä¾‹å¦‚ï¼Œè®¾ç½®æ—¥å¿—çº§åˆ«ã€è¾“å‡ºæ ¼å¼ã€ç›®æ ‡æ–‡ä»¶/æ§åˆ¶å°ï¼‰ã€‚
- æä¾›ä¸åŒæ—¥å¿—çº§åˆ«çš„è®°å½•æ¥å£ï¼ˆDEBUG, INFO, WARN, ERROR, CRITICALï¼‰ã€‚
- ï¼ˆå¯é€‰ï¼‰æ”¯æŒå¼‚æ­¥æ—¥å¿—è®°å½•ä»¥å‡å°‘å¯¹ä¸šåŠ¡çº¿ç¨‹çš„å½±å“ã€‚

**3. æ ¸å¿ƒå¯¹å¤–æ¥å£ (Key Public APIs - åˆæ­¥è®¾æƒ³):**

- (é€šå¸¸æ˜¯å¯¹ `spdlog` çš„ç®€å•å°è£…æˆ–ç›´æ¥ä½¿ç”¨å…¶API)
- `Logger::init(...)`
- `LOG_DEBUG("message with arg {}", arg1)`
- `LOG_INFO(...)`, `LOG_WARN(...)`, `LOG_ERROR(...)`

**4. è¢«å“ªäº›æ¨¡å—ä¾èµ– (Depended On By):**

- å‡ ä¹æ‰€æœ‰å…¶ä»–æ¨¡å—ã€‚

---

### **ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ ¸å¿ƒé€»è¾‘æ¨¡å— (Core Logic)**

#### **æ¨¡å— 3.1: `core_logic/config_manager/` - é…ç½®ç®¡ç†å™¨**

1. æ¦‚è¿° (Overview):

è´Ÿè´£åœ¨ç¨‹åºå¯åŠ¨æ—¶åŠ è½½æ‰€æœ‰å¿…è¦çš„é…ç½®ä¿¡æ¯ï¼Œå¹¶æä¾›ç»™å…¶ä»–æ¨¡å—è®¿é—®ã€‚

**2. ä¸»è¦èŒè´£ (Key Responsibilities):**

- ä»é…ç½®æ–‡ä»¶ï¼ˆä¾‹å¦‚JSONæ ¼å¼ï¼‰ä¸­è¯»å–ï¼š
    - Bridgeè‡ªèº«çš„ç›‘å¬è®¾ç½®ï¼ˆä¾‹å¦‚ï¼Œç”¨äºZKä¿¡ä»¤çš„10ä¸ªç«¯å£ï¼ŒTMSä¿¡ä»¤ç«¯å£ï¼‰ã€‚
    - TMSæœåŠ¡å™¨çš„è¿æ¥ä¿¡æ¯ (IP, Port)ã€‚
    - ZKå®ä½“çš„åŸºç¡€ä¿¡æ¯åˆ—è¡¨ (å¦‚æœæ¯ä¸ªZKæœ‰ç‰¹å®šé…ç½®éœ€è¦é¢„åŠ è½½)ã€‚
    - "cué…ç½®è¡¨" å’Œ "cuå’Œtarget_idæ˜ å°„è¡¨"ã€‚
    - ç«¯å£ç®¡ç†å™¨å¯ç”¨çš„ç«¯å£èŒƒå›´ã€‚
    - æ—¥å¿—çº§åˆ«ã€çº¿ç¨‹æ± å¤§å°ç­‰ç³»ç»Ÿå‚æ•°ã€‚
- è§£æå¹¶æ ¡éªŒé…ç½®ä¿¡æ¯çš„æœ‰æ•ˆæ€§ã€‚
- æä¾›çº¿ç¨‹å®‰å…¨çš„æ¥å£ä¾›å…¶ä»–æ¨¡å—æŸ¥è¯¢é…ç½®ã€‚é…ç½®é€šå¸¸åœ¨å¯åŠ¨åæ˜¯åªè¯»çš„ã€‚

**3. æ ¸å¿ƒå¯¹å¤–æ¥å£ (Key Public APIs - åˆæ­¥è®¾æƒ³):**

- `ConfigManager::instance().load_config(const std::string& filepath);`
- `const TmsConfig& ConfigManager::instance().get_tms_config();`
- `std::optional<ZkConfig> ConfigManager::instance().get_zk_config(const ZkId& zk_id);`
- `const CuConfigTable& ConfigManager::instance().get_cu_config_table();`
- `// ...`

**4. ä¾èµ–çš„å…¶ä»–æ¨¡å— (Dependencies):**

- JSONè§£æåº“ (ä¾‹å¦‚ `nlohmann/json`)ã€‚
- C++æ ‡å‡†åº“ (`<fstream>`, `<string>`, `<vector>`, `<map>`)ã€‚

**5. è¢«å“ªäº›æ¨¡å—ä¾èµ– (Depended On By):**

- å‡ ä¹æ‰€æœ‰å…¶ä»–æ¨¡å—åœ¨åˆå§‹åŒ–æˆ–è¿è¡Œæ—¶éƒ½éœ€è¦é…ç½®ä¿¡æ¯ã€‚

---

**(æ¥ä¸‹æ¥çš„æ¨¡å—å®šä¹‰ï¼Œå¦‚ `interfaces/*`, `Coordinator`, `SessionManager`, `Session`, `PortManager`, `MediaRelay` å°†éµå¾ªç±»ä¼¼çš„æ¨¡æ¿ï¼Œç»†åŒ–å…¶èŒè´£ã€æ¥å£å’Œå…³é”®æ•°æ®ç»“æ„ï¼Œå¹¶ç‰¹åˆ«å¼ºè°ƒå®ƒä»¬å¦‚ä½•åœ¨å¤šçº¿ç¨‹å’Œäº‹ä»¶é©±åŠ¨æ¨¡å‹ä¸‹å·¥ä½œï¼Œä»¥åŠå¦‚ä½•ä¿è¯çº¿ç¨‹å®‰å…¨ã€‚) **

**ä¾‹å¦‚ï¼Œå¯¹äº `Session` å¯¹è±¡ï¼Œå…¶æ ¸å¿ƒèŒè´£ä¹‹ä¸€å°±æ˜¯å®ç°ä¸€ä¸ªçŠ¶æ€æœºæ¥ç®¡ç†å‘¼å«çš„å®Œæ•´ç”Ÿå‘½å‘¨æœŸï¼Œå®ƒçš„æ–¹æ³•ï¼ˆå¦‚ `handleZkEvent`ï¼‰å°†åœ¨å·¥ä½œçº¿ç¨‹ä¸­è¢«è°ƒç”¨ã€‚**

**å¯¹äº `MediaRelay`ï¼Œå…¶å†…éƒ¨çš„è½¬å‘è¡¨åœ¨è¢«å·¥ä½œçº¿ç¨‹ï¼ˆç”±Sessioné€»è¾‘é©±åŠ¨ï¼‰æ›´æ–°æ—¶éœ€è¦åŠ é”ï¼Œè€ŒI/Oçº¿ç¨‹åœ¨è¯»å–è½¬å‘è¡¨è¿›è¡Œåª’ä½“è½¬å‘æ—¶ï¼Œå¯ä»¥ä½¿ç”¨æ›´è½»é‡çº§çš„åŒæ­¥æœºåˆ¶ï¼ˆå¦‚è¯»å†™é”æˆ–æ— é”æ•°æ®ç»“æ„ï¼Œå¦‚æœé€‚ç”¨ä¸”å®ç°æ­£ç¡®çš„è¯ï¼‰ï¼Œæˆ–è€…ä¿è¯è½¬å‘è¡¨çš„æ›´æ–°æ˜¯éå¸¸å¿«é€Ÿçš„åŸå­æ“ä½œï¼ˆä¾‹å¦‚æ›¿æ¢æŒ‡é’ˆï¼‰æ¥æœ€å°åŒ–å¯¹I/Oçº¿ç¨‹çš„å½±å“ã€‚**

---

è¿™ä¸ªè¯¦ç»†è®¾è®¡è¿‡ç¨‹ä¼šæ¯”è¾ƒè€—æ—¶ï¼Œä½†å¯¹äºåç»­çš„é¡ºåˆ©å¼€å‘è‡³å…³é‡è¦ã€‚æˆ‘ä»¬å¯ä»¥å…ˆé›†ä¸­ç²¾åŠ›æŠŠ `protocols/zk_protocol/` æ¨¡å—çš„ **æ ¸å¿ƒå¯¹å¤–æ¥å£ (ç‰¹åˆ«æ˜¯æ¶ˆæ¯ç»“æ„ä½“å’Œç¼–è§£ç å‡½æ•°ç­¾å)** ç¡®å®šä¸‹æ¥ï¼Œå› ä¸ºè¿™æ˜¯å¾ˆå¤šå…¶ä»–æ¨¡å—çš„åŸºç¡€ã€‚

ç„¶åæˆ‘ä»¬å¯ä»¥è®¨è®º `interfaces/zk_interface/` å¦‚ä½•ä½¿ç”¨å®ƒï¼Œä»¥åŠå®ƒå¦‚ä½•ä¸I/Oçº¿ç¨‹å’Œå·¥ä½œçº¿ç¨‹æ± çš„ä»»åŠ¡é˜Ÿåˆ—äº¤äº’ã€‚

æ‚¨è§‰å¾—è¿™ä¸ªæ–¹å‘å’Œç»†åŒ–ç¨‹åº¦å¦‚ä½•ï¼Ÿæˆ‘ä»¬å¯ä»¥å…ˆé’ˆå¯¹ `protocols/zk_protocol/` æŠŠç¬¬7ç‚¹â€œæ ¸å¿ƒå¯¹å¤–æ¥å£â€å†å…·ä½“åŒ–ä¸€ä¸‹å—ï¼Ÿä¾‹å¦‚ï¼Œæ‚¨ZKåè®®ä¸­æœ€é‡è¦çš„å‡ æ¡ä¿¡ä»¤æ¶ˆæ¯æ˜¯ä»€ä¹ˆï¼Ÿå®ƒä»¬åŒ…å«å“ªäº›å…³é”®å­—æ®µï¼Ÿ






å¥½çš„ï¼Œè¿™ç»å¯¹æ˜¯ä¸€ä¸ªå…³é”®çš„é‡Œç¨‹ç¢‘ï¼ç°åœ¨ï¼Œæˆ‘ä»¬å°†æŠŠä¹‹å‰æ‰€æœ‰å…³äº Bridge ç³»ç»Ÿæ¶æ„çš„è®¨è®ºï¼ŒåŒ…æ‹¬æ¨¡å—åˆ’åˆ†ã€æ ¸å¿ƒèŒè´£ã€I/Oæ¨¡å‹ã€å¤šçº¿ç¨‹ã€åè®®å¤„ç†ç»†èŠ‚ï¼Œä»¥åŠæœ€æ–°åŠ å…¥çš„**ä¸»å¤‡å®¹ç¾**è€ƒé‡ï¼Œæ•´åˆåˆ°ä¸€ä»½ç»“æ„è®¾è®¡æ–‡æ¡£ä¸­ã€‚

è¿™ä»½æ–‡æ¡£å°†ä½œä¸ºæ‚¨åç»­è¯¦ç»†è®¾è®¡å’Œç¼–ç çš„è“å›¾ã€‚

---

## Bridge ç³»ç»Ÿç»“æ„è®¾è®¡è¯´æ˜æ–‡æ¡£ V1.0 ğŸŒ‰

æ–‡æ¡£ç‰ˆæœ¬ï¼š 1.0

æ—¥æœŸï¼š 2025-05-27 (æ ¹æ®æ‚¨å½“å‰æ—¶é—´è°ƒæ•´)

ä½œè€…ï¼š (æ‚¨çš„åå­—/å›¢é˜Ÿ)

### 1. å¼•è¨€ ğŸ“œ

#### 1.1. é¡¹ç›®æ¦‚è¿°

Bridge ç³»ç»Ÿæ˜¯ä¸€ä¸ªä¸­é—´ä»¶ç¨‹åºï¼Œæ—¨åœ¨ä½œä¸º ZK å®ä½“ï¼ˆæœ€å¤š10ä¸ªï¼Œæ¯ä¸ªZKä½¿ç”¨å•ä¸€å›ºå®šç«¯å£è¿›è¡Œä¿¡ä»¤å’Œåª’ä½“é€šä¿¡ï¼‰ä¸å•ä¸€ TMS ç³»ç»Ÿä¹‹é—´çš„é€šä¿¡æ¡¥æ¢ã€‚å®ƒè´Ÿè´£åœ¨ä¸¤è€…ä¹‹é—´è¿›è¡Œä¿¡ä»¤äº¤äº’çš„åè®®é€‚é…å’Œåª’ä½“æµçš„è½¬å‘ã€‚ç³»ç»Ÿè®¾è®¡ç›®æ ‡æ˜¯æ”¯æŒæœ€å¤š200è·¯å¹¶å‘ä¼šè¯ï¼Œå¹¶å…·å¤‡ä¸»å¤‡å®¹ç¾èƒ½åŠ›ã€‚

#### 1.2. è®¾è®¡ç›®æ ‡

- **åŠŸèƒ½æ€§ï¼š** å‡†ç¡®å®ç°ZKä¸TMSé—´çš„ä¿¡ä»¤è½¬æ¢å’Œåª’ä½“ä¸­ç»§ã€‚
- **æ€§èƒ½ï¼š** é«˜æ•ˆå¤„ç†200è·¯å¹¶å‘ä¼šè¯ï¼Œä½å»¶è¿Ÿã€‚
- **å¯é æ€§ï¼š** ç³»ç»Ÿç¨³å®šè¿è¡Œï¼Œå…·å¤‡ä¸»å¤‡å®¹ç¾èƒ½åŠ›ï¼Œå‡å°‘å•ç‚¹æ•…éšœæ—¶é—´ã€‚
- **å¯ç»´æŠ¤æ€§ï¼š** æ¨¡å—åŒ–è®¾è®¡ï¼Œä»£ç æ¸…æ™°ï¼Œæ˜“äºç†è§£ã€ä¿®æ”¹å’Œæ‰©å±•ã€‚
- **å¯æ‰©å±•æ€§ï¼š** æ¶æ„ä¸Šä¸ºæœªæ¥å¯èƒ½çš„ä¼šè¯æ•°é‡å¢é•¿æˆ–åŠŸèƒ½å¢å¼ºç•™æœ‰ä½™åœ°ã€‚

#### 1.3. å…³é”®çº¦æŸ

- C++11 ä½œä¸ºå¼€å‘è¯­è¨€æ ‡å‡†ã€‚
- ç›®æ ‡è¿è¡Œç¯å¢ƒï¼šéº’éºŸæœåŠ¡å™¨æ“ä½œç³»ç»Ÿ (Linux 4.4.131 aarch64, GCC 5.4.0)ã€‚
- ZKä¾§é€šä¿¡ï¼šæ¯ä¸ªZKä½¿ç”¨ä¸€ä¸ªå›ºå®šç«¯å£ä¸Bridgeçš„å¯¹åº”ZKç›‘å¬ç«¯å£è¿›è¡Œæ‰€æœ‰ä¿¡ä»¤åŠæ‰€æœ‰ä¼šè¯çš„åª’ä½“æ•°æ®äº¤äº’ï¼›Bridgeå‘ZKå‘é€åª’ä½“æ—¶ï¼Œä½¿ç”¨ä¸ºè¯¥ä¼šè¯åˆ†é…çš„ç‹¬ç«‹æºç«¯å£ã€‚
- TMSä¾§é€šä¿¡ï¼šåè®®å¾…æ˜ç¡®ï¼ˆå‡è®¾TCPä¿¡ä»¤ï¼ŒUDPåª’ä½“ï¼‰ã€‚

---

### 2. ç³»ç»Ÿæ€»ä½“æ¶æ„ ğŸ—ï¸

Bridge ç³»ç»Ÿé‡‡ç”¨**æ¨¡å—åŒ–ã€äº‹ä»¶é©±åŠ¨ã€I/Oå¤ç”¨ï¼ˆåŸºäºepollæˆ–ç­‰æ•ˆæœºåˆ¶ï¼‰å’Œå¤šçº¿ç¨‹ï¼ˆI/Oçº¿ç¨‹ + å·¥ä½œçº¿ç¨‹æ± ï¼‰**çš„æ¶æ„ã€‚

#### 2.1. æ¶æ„å›¾ (æ¦‚å¿µ)

```
+---------------------+      +-----------------------+      +---------------------+
|     ZK Entities     |<---->|      ZK Interface     |<---->|                     |
| (10 ZKs, fixed port |      | (10 Listeners for ZK  |      |                     |
|  for Sig & Media In)|      |  Sig/Media, Demux,    |      |   Coordinator /   |
+---------------------+      |  Reliability Handler, |      |   Event Router    |      +-------------------+
                             |  Protocol Util)       |      |                     |----->|  Session Module   |
                             +-----------+-----------+      +---------------------+      |<-----| (SessionManager,  |
                                         ^                                               |      |  Session Objects) |
                                         | (Tasks to Worker Pool)                        |      +-------------------+
                                         v                                               |                |
+---------------------+      +-----------+-----------+      +-----------------------+  |                | (Config MediaRelay)
|     TMS System      |<---->|     TMS Interface     |<---->|   Worker Thread Pool  |  |                v
| (TCP Sig, N UDP     |      | (TCP Conn, N UDP Listen|      | (Executes Session Logic,|  |      +-------------------+
|  Media In)          |      |  for TMS Media, Proto |      |  Coordinator, etc.)   |<---------->| MediaRelay Module |
+---------------------+      |  Util)                |      +-----------------------+  |      |(Fast Fwd Table,   |
                             +-----------+-----------+                                   |      | Header Manip.)    |
                                         ^                                               |      +-------------------+
                                         | (Tasks to Worker Pool)                        |
                                         v                                               |  ^
                             +-----------------------+                                   |  | (Alloc/Release)
                             | I/O Threads &         |                                   v  |
                             | Event Loop (epoll)    |      +-----------------------+     +-----------------------+
                             +-----------------------+      | Communication Layer   |<--->|    Protocol Layer     |
                                     ^       ^              | (Async Sockets)       |     | (ZK/TMS Parsers/Fmts) |
                                     |       |              +-----------------------+     +-----------------------+
                                     |       |
                                     |       +-------------------------------------------->+    Port Manager       |
                                     |                                                     | (UDP Port Pool)       |
                                     +----------------------------------------------------->+-----------------------+

+-----------------------+     +-----------------------+     +-----------------------+
| Configuration Manager |     |     Logging (spdlog)  |     | Redis Client Interface|
| (JSON for config)     |     +-----------------------+     | (for HA State Sync)   |
+-----------------------+                                   +-----------------------+
                                                                      ^
                                                                      | (HA Heartbeat & State)
                                                                      v
                                                            +-----------------------+
                                                            | HA Switch Logic Module|
                                                            | (e.g., ms_switch)     |
                                                            +-----------------------+
```

#### 2.2. çº¿ç¨‹æ¨¡å‹

- **I/O çº¿ç¨‹ (å°‘é‡)ï¼š**
    - è¿è¡Œæ ¸å¿ƒI/Oå¤ç”¨å¾ªç¯ (å¦‚ `epoll_wait`)ã€‚
    - è´Ÿè´£æ‰€æœ‰Socketçš„éé˜»å¡è¯»å†™ã€‚
    - è¿›è¡Œæœ€å°åŒ–è§£æä»¥è¯†åˆ«æ¶ˆæ¯æ¥æºå’ŒåŸºæœ¬ç±»å‹ã€‚
    - å°†ä»»åŠ¡åˆ†å‘åˆ°å·¥ä½œçº¿ç¨‹æ± ã€‚
    - å¯èƒ½ç›´æ¥å¤„ç†æä½å»¶è¿Ÿçš„åª’ä½“è½¬å‘ï¼ˆå¦‚æœåŒ…å¤´æ“ä½œç®€å•ï¼‰ã€‚
- **å·¥ä½œçº¿ç¨‹æ±  (å›ºå®šæ•°é‡)ï¼š**
    - æ‰§è¡Œæ‰€æœ‰æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼š`Session`çŠ¶æ€æœºã€`Coordinator`è·¯ç”±ã€é…ç½®è¯»å–ã€ç«¯å£åˆ†é…ã€`MediaRelay`é…ç½®ã€‚
    - å¤„ç†éœ€è¦CPUè®¡ç®—æˆ–å¯èƒ½çŸ­æ—¶é˜»å¡ï¼ˆéç½‘ç»œI/Oï¼‰çš„æ“ä½œã€‚
- **(å¯é€‰) ä¸“ç”¨çº¿ç¨‹ï¼š** TMSå¿ƒè·³ã€å®šæ—¶æ¸…ç†ã€HAçŠ¶æ€ç›‘æ§ç­‰ã€‚

---

### 3. æ¨¡å—è¯¦ç»†è®¾è®¡ ğŸ§©

#### 3.1. `common/` - é€šç”¨åŸºç¡€æ¨¡å—

- **`common/communication/` - é€šä¿¡å±‚**
    - **æ¦‚è¿°ï¼š** æä¾›åº•å±‚çš„ã€å¼‚æ­¥çš„ã€å¹³å°æ— å…³ï¼ˆæˆ–å·²é€‚é…ç›®æ ‡å¹³å°ï¼‰çš„Socketæ“ä½œå°è£…ã€‚
    - **ä¸»è¦èŒè´£ï¼š** å°è£…å¼‚æ­¥UDP Socketçš„åˆ›å»ºã€ç»‘å®šã€æ”¶å‘ï¼›å°è£…å¼‚æ­¥TCPå®¢æˆ·ç«¯/æœåŠ¡å™¨Socketæ“ä½œã€‚ä¸I/Oäº‹ä»¶å¾ªç¯é›†æˆã€‚
    - **æ ¸å¿ƒæ¥å£ï¼š** `AsyncUDPSocket::async_receive_from()`, `AsyncUDPSocket::async_send_to()`, `AsyncTCPClient::async_connect()`, `AsyncTCPClient::async_send()` ç­‰ã€‚
    - **ä¸»è¦æ•°æ®ç»“æ„ï¼š** Socketæè¿°ç¬¦ã€ç¼“å†²åŒºã€å›è°ƒå‡½æ•°å¯¹è±¡ã€‚
- **`common/task_queue/` - ä»»åŠ¡é˜Ÿåˆ—**
    - **æ¦‚è¿°ï¼š** å®ç°çº¿ç¨‹å®‰å…¨çš„ä»»åŠ¡é˜Ÿåˆ—ï¼Œç”¨äºI/Oçº¿ç¨‹ä¸å·¥ä½œçº¿ç¨‹æ± ä¹‹é—´çš„ä»»åŠ¡ä¼ é€’ã€‚
    - **æ ¸å¿ƒæ¥å£ï¼š** `ConcurrentQueue::push(Task)`, `ConcurrentQueue::wait_and_pop()`ã€‚

#### 3.2. `protocols/` - åè®®å±‚

- **`protocols/zk_protocol/` - ZKåè®®å¤„ç†**
    - **æ¦‚è¿°ï¼š** å®šä¹‰ZKåè®®æ¶ˆæ¯çš„C++æ•°æ®ç»“æ„ï¼Œæä¾›çº¯ç²¹çš„ç¼–è§£ç åŠŸèƒ½ï¼ˆå­—èŠ‚æµ <-> C++ç»“æ„ä½“ï¼‰ï¼Œå¤„ç†å­—èŠ‚åºã€‚**ä¸åŒ…å«è‡ªå®šä¹‰å¯é ä¼ è¾“çš„çŠ¶æ€é€»è¾‘ã€‚**
    - **ä¸»è¦èŒè´£ï¼š**
        - å®šä¹‰ `CommonHeader` (åºåˆ—å·ã€ACKå·ã€æ ‡å¿—ä½ã€æº/ç›®æ ‡å®ä½“IDã€ä¿¡æ¯å•å…ƒæ•°é‡)ã€‚
        - å®šä¹‰ `InformationUnitType` æšä¸¾ã€‚
        - å®šä¹‰æ¯ç§ `InformationUnitType` å¯¹åº”çš„è½½è·ç»“æ„ä½“ (`XxxIU`)ã€‚
        - å®šä¹‰é¡¶å±‚å·²è§£æZK UDPåŒ…ç»“æ„ä½“ `ParsedZkUdpPacket { CommonHeader header; std::vector<std::shared_ptr<BaseIU>> information_units; }` (å…¶ä¸­ `BaseIU` ä¸ºä¿¡æ¯å•å…ƒçš„åŸºç±»ï¼Œå…·ä½“å•å…ƒä¸ºå…¶æ´¾ç”Ÿç±»ï¼Œä»¥é€‚åº”C++11ä¸‹ `std::variant` çš„ç¼ºå¤±)ã€‚
    - **æ ¸å¿ƒæ¥å£ï¼š**
        - `ZkProtocol::Parser::decode_common_header(buffer, len)`
        - `ZkProtocol::Parser::decode_information_unit_payload(buffer, len, type, BaseIU*& out_unit)` (æˆ–å¤šä¸ªç‰¹å®šç±»å‹çš„è§£ç å‡½æ•°)
        - `ZkProtocol::Parser::decode_packet(buffer, len, ParsedZkUdpPacket& out_packet)` (é¡¶å±‚è§£æï¼Œå¾ªç¯è§£æä¿¡æ¯å•å…ƒ)
        - `ZkProtocol::Formatter::encode_packet(const ParsedZkUdpPacket& packet)` (é¡¶å±‚ç¼–ç )
        - `ZkProtocol::Formatter::encode_raw_media_for_zk(CommonHeader& header_template, payload, len)` (ä¾›MediaRelayä½¿ç”¨ï¼Œå¯é æ€§å­—æ®µç”±ä¸Šå±‚å¡«å……)
- **`protocols/tms_protocol/` - TMSåè®®å¤„ç†**
    - **æ¦‚è¿°ä¸èŒè´£ï¼š** åŒZKåè®®æ¨¡å—ï¼Œä½†é’ˆå¯¹TMSåè®®ã€‚

#### 3.3. `interfaces/` - æ¥å£é€‚é…å±‚

- **`interfaces/zk_interface/` - ZKæ¥å£é€‚é…å™¨**
    - **æ¦‚è¿°ï¼š** å¤„ç†ä¸æ‰€æœ‰ZKå®ä½“çš„ç½‘ç»œé€šä¿¡ã€åè®®ç¼–è§£ç è°ƒç”¨ã€è‡ªå®šä¹‰å¯é UDPä¼ è¾“æœºåˆ¶ï¼ˆå¦‚æœZKåè®®éœ€è¦ï¼‰ï¼Œå¹¶å°†ä¸šåŠ¡äº‹ä»¶è·¯ç”±åˆ° `Coordinator`ã€‚
    - **ä¸»è¦èŒè´£ï¼š**
        - **`ZkListener`:** ç®¡ç†10ä¸ªUDPç›‘å¬Socketï¼ˆæ¯ä¸ªZKä¸€ä¸ªï¼Œæ¥æ”¶å…¶ä¿¡ä»¤å’Œæ‰€æœ‰ä¼šè¯çš„åª’ä½“ï¼‰ã€‚ä½¿ç”¨`common/communication`å’Œ`epoll`ã€‚è¯»å–æ•°æ®åï¼Œè°ƒç”¨`protocols/zk_protocol`åˆæ­¥è§£æã€‚
        - **`ZkReliabilityHandler` (å¦‚æœZKåè®®æœ‰è‡ªå®šä¹‰å¯é æ€§):** åŸºäº`CommonHeader`ä¸­çš„åºåˆ—å·/ACK/æ ‡å¿—ä½å®ç°æ¶ˆæ¯çš„å¯é å‘é€ï¼ˆé‡ä¼ ã€è¶…æ—¶ï¼‰å’Œæ¥æ”¶ï¼ˆå»é‡ã€æ’åºã€å‘é€ACKï¼‰ã€‚å®ƒä¼šä½¿ç”¨`protocols/zk_protocol`æ¥ç¼–è§£ç å¤´éƒ¨å­—æ®µï¼Œä½†å¯é æ€§çŠ¶æ€æœºåœ¨æ­¤æ¨¡å—ã€‚
        - **å†…å®¹åˆ†å‘ï¼š** è§£æZKåŒ…å¤´ï¼ˆæˆ–ç”±`ZkReliabilityHandler`å¤„ç†åçš„åŒ…ï¼‰ä¸­çš„â€œä¿¡æ¯å•å…ƒä¼šè¯æ ‡è¯†â€å’Œâ€œä¿¡æ¯å•å…ƒç±»å‹â€ã€‚
            - ä¿¡ä»¤ç±»ä¿¡æ¯å•å…ƒï¼šå°è£…æˆä»»åŠ¡ï¼Œé€šè¿‡`Coordinator`æäº¤ç»™`Session`å¤„ç†ã€‚
            - åª’ä½“ç±»ä¿¡æ¯å•å…ƒï¼šç›´æ¥ï¼ˆæˆ–é€šè¿‡é«˜ä¼˜å…ˆçº§ä»»åŠ¡ï¼‰äº¤ç»™`MediaRelay`å¤„ç†ã€‚
        - **`ZkSender`:** æ¥æ”¶æ¥è‡ª`Coordinator`ï¼ˆæºè‡ª`Session`æˆ–`MediaRelay`ï¼‰çš„å‘é€æŒ‡ä»¤ï¼Œè°ƒç”¨`ZkReliabilityHandler`ï¼ˆå¦‚æœéœ€è¦å¯é æ€§ï¼‰æˆ–ç›´æ¥è°ƒç”¨`protocols/zk_protocol`æ ¼å¼åŒ–æ¶ˆæ¯ï¼Œå¹¶é€šè¿‡`common/communication`å‘é€ã€‚
    - **æ ¸å¿ƒæ•°æ®ç»“æ„ï¼š** æ¯ä¸ªZKç›‘å¬Socketçš„ä¸Šä¸‹æ–‡ï¼Œå¯é ä¼ è¾“ç›¸å…³çš„çŠ¶æ€è¡¨ï¼ˆå¦‚å‘é€çª—å£ã€é‡ä¼ é˜Ÿåˆ—ï¼‰ã€‚
- **`interfaces/tms_interface/` - TMSæ¥å£é€‚é…å™¨**
    - **æ¦‚è¿°ä¸èŒè´£ï¼š** ç±»ä¼¼ZKæ¥å£ï¼Œä½†é’ˆå¯¹TMSã€‚ç®¡ç†ä¸TMSçš„TCPä¿¡ä»¤è¿æ¥ï¼ˆå¿ƒè·³ï¼‰ï¼Œç®¡ç†Nä¸ªUDP Socketæ¥æ”¶æ¥è‡ªTMSçš„åª’ä½“ã€‚

#### 3.4. `core_logic/` - æ ¸å¿ƒä¸šåŠ¡é€»è¾‘æ¨¡å—

- **`core_logic/coordinator/` - åè°ƒå™¨**
    - **æ¦‚è¿°ï¼š** è¿è¡Œåœ¨å·¥ä½œçº¿ç¨‹ä¸­ï¼Œä½œä¸ºæ¥å£å±‚å’Œä¼šè¯æ¨¡å—ä¹‹é—´çš„é€»è¾‘è·¯ç”±å™¨ã€‚
    - **ä¸»è¦èŒè´£ï¼š** æ¥æ”¶æ¥è‡ªæ¥å£å±‚ï¼ˆ`zk_interface`, `tms_interface`ï¼‰çš„å·²è§£æä¸šåŠ¡äº‹ä»¶/ä¿¡ä»¤ï¼Œå°†å…¶è·¯ç”±åˆ°`SessionManager`ï¼ˆç”¨äºæŸ¥æ‰¾æˆ–åˆ›å»º`Session`ï¼‰æˆ–ç›´æ¥è·¯ç”±åˆ°å·²å­˜åœ¨çš„`Session`å¯¹è±¡çš„æ–¹æ³•ã€‚åä¹‹ï¼Œæ¥æ”¶æ¥è‡ª`Session`å¯¹è±¡çš„æŒ‡ä»¤ï¼Œå°†å…¶è·¯ç”±åˆ°ç›¸åº”çš„æ¥å£å±‚è¿›è¡Œç½‘ç»œå‘é€ã€‚
- **`core_logic/session_manager/` - ä¼šè¯ç®¡ç†å™¨**
    - **æ¦‚è¿°ï¼š** è¿è¡Œåœ¨å·¥ä½œçº¿ç¨‹ä¸­ï¼Œç®¡ç†æ‰€æœ‰æ´»åŠ¨ä¼šè¯çš„ç”Ÿå‘½å‘¨æœŸã€‚
    - **ä¸»è¦èŒè´£ï¼š** ç»´æŠ¤ä¸€ä¸ª**çº¿ç¨‹å®‰å…¨**çš„ä¼šè¯è¡¨ï¼ˆå¦‚ `std::unordered_map<SessionID, std::shared_ptr<Session>>`ï¼‰ã€‚è´Ÿè´£ä¼šè¯çš„åˆ›å»ºã€æŸ¥æ‰¾ã€é”€æ¯ã€‚
    - **ä¸HA/Redisäº¤äº’ï¼š** åœ¨ä¼šè¯åˆ›å»ºã€å…³é”®çŠ¶æ€å˜æ›´ã€é”€æ¯æ—¶ï¼Œ**å¼‚æ­¥**åœ°å°†å¿…è¦ä¿¡æ¯å†™å…¥Redisï¼ˆé€šè¿‡`RedisClientInterface`ï¼‰ï¼Œä»¥ä¾›å¤‡æœºæ¢å¤ã€‚
- **`core_logic/session/` - ä¼šè¯å¯¹è±¡**
    - **æ¦‚è¿°ï¼š** è¿è¡Œåœ¨å·¥ä½œçº¿ç¨‹ä¸­ï¼Œå°è£…å•ä¸ªç«¯åˆ°ç«¯å‘¼å«çš„æ ¸å¿ƒçŠ¶æ€æœºå’Œä¸šåŠ¡æµç¨‹ã€‚
    - **ä¸»è¦èŒè´£ï¼š**
        - ç®¡ç†ä¼šè¯çŠ¶æ€ï¼ˆåˆå§‹åŒ–ã€è¿æ¥ä¸­ã€æ¿€æ´»ã€æ‹†é™¤ä¸­ç­‰ï¼‰ã€‚
        - å¤„ç†æ¥è‡ªZKæˆ–TMSçš„ç‰¹å®šä¿¡ä»¤äº‹ä»¶ï¼ˆç”±`Coordinator`è·¯ç”±è€Œæ¥ï¼‰ã€‚
        - å†³ç­–å¹¶è§¦å‘å‘ZKæˆ–TMSå‘é€ä¿¡ä»¤ï¼ˆé€šè¿‡`Coordinator`ï¼‰ã€‚
        - è°ƒç”¨`PortManager`åˆ†é…/é‡Šæ”¾åª’ä½“ç«¯å£ã€‚
        - è°ƒç”¨`MediaRelay`é…ç½®/æ¸…é™¤åª’ä½“è½¬å‘è§„åˆ™ã€‚
        - ç®¡ç†ä¼šè¯ç›¸å…³çš„å®šæ—¶å™¨ï¼ˆå¦‚å‘¼å«è¶…æ—¶ï¼‰ã€‚
    - **æ ¸å¿ƒæ•°æ®ç»“æ„ï¼š** ä¼šè¯IDï¼ŒZK/TMSç«¯ç‚¹ä¿¡æ¯ï¼Œåˆ†é…çš„Bridgeåª’ä½“ç«¯å£ï¼Œå½“å‰çŠ¶æ€ï¼Œå…³è”çš„CUé…ç½®ç­‰ã€‚
- **`core_logic/port_manager/` - ç«¯å£ç®¡ç†å™¨**
    - **æ¦‚è¿°ï¼š** è¿è¡Œåœ¨å·¥ä½œçº¿ç¨‹ä¸­ï¼ˆæˆ–å…¶æ“ä½œè¢«å°è£…ä¸ºä»»åŠ¡ï¼‰ï¼Œç®¡ç†Bridgeå¯ç”¨çš„UDPåª’ä½“ç«¯å£æ± ã€‚
    - **ä¸»è¦èŒè´£ï¼š** æä¾›**çº¿ç¨‹å®‰å…¨**çš„ç«¯å£åˆ†é…å’Œå›æ”¶æ¥å£ã€‚
- **`core_logic/config_manager/` - é…ç½®ç®¡ç†å™¨**
    - **æ¦‚è¿°ï¼š** ç¨‹åºå¯åŠ¨æ—¶åŠ è½½é…ç½®ï¼Œä¹‹åæä¾›åªè¯»è®¿é—®ã€‚
    - **ä¸»è¦èŒè´£ï¼š** è§£æJSONé…ç½®æ–‡ä»¶ï¼Œæä¾›å¯¹ZK/TMSè¿æ¥ä¿¡æ¯ã€CUé…ç½®è¡¨ã€æ˜ å°„è¡¨ç­‰çš„è®¿é—®ã€‚

#### 3.5. `media_processing/media_relay/` - åª’ä½“ä¸­ç»§æ¨¡å—

- **æ¦‚è¿°ï¼š** è´Ÿè´£é«˜æ•ˆçš„UDPåª’ä½“åŒ…è½¬å‘ã€‚
- **ä¸»è¦èŒè´£ï¼š**
    - ç»´æŠ¤ä¸€ä¸ª**çº¿ç¨‹å®‰å…¨**çš„ã€é«˜æ•ˆçš„å†…éƒ¨åª’ä½“è½¬å‘è¡¨ï¼ˆ`ActiveMediaFlowTable`ï¼‰ï¼Œé”®ä¸ºBridgeæœ¬åœ°æ¥æ”¶åª’ä½“çš„UDPç«¯å£ï¼ˆå¯¹äºTMSä¾§ï¼‰æˆ–ZKä¼šè¯æ ‡è¯†ï¼ˆå¯¹äºZKå…±äº«å…¥å£ä¾§ï¼‰ï¼Œå€¼ä¸ºè½¬å‘è§„åˆ™ï¼ˆç›®æ ‡IP/ç«¯å£ã€åŒ…å¤´å¤„ç†å‡½æ•°ã€å‘é€ç”¨çš„Bridgeæºç«¯å£ï¼‰ã€‚
    - ç”±`Session`å¯¹è±¡åœ¨ä¼šè¯å»ºç«‹/æ‹†é™¤æ—¶è°ƒç”¨å…¶æ¥å£æ¥é…ç½®/æ¸…é™¤è½¬å‘è§„åˆ™ã€‚
    - **è½¬å‘é€»è¾‘ï¼ˆå¯èƒ½åœ¨I/Oçº¿ç¨‹ä¸­ç›´æ¥æ‰§è¡Œä»¥é™ä½å»¶è¿Ÿï¼‰ï¼š**
        - æ”¶åˆ°åª’ä½“åŒ…åï¼Œå¿«é€ŸæŸ¥è½¬å‘è¡¨ã€‚
        - æ‰§è¡ŒæŒ‡å®šçš„â€œåŠ /å»ZKé€šç”¨æŠ¥å¤´â€æ“ä½œ (è°ƒç”¨`protocols/zk_protocol`çš„åª’ä½“å°è£…/è§£å°è£…å‡½æ•°)ã€‚
        - é€šè¿‡`common/communication`å°†å¤„ç†åçš„åŒ…å¼‚æ­¥å‘é€å‡ºå»ã€‚
    - ï¼ˆå¯é€‰ï¼‰å®ç°ç®€å•çš„åª’ä½“åŒ…ç¼“å†²æœºåˆ¶ã€‚

#### 3.6. `ha_module/` (æˆ– `ms_switch` ç›¸å…³é€»è¾‘çš„å°è£…) - ä¸»å¤‡å®¹ç¾æ¨¡å—

- **æ¦‚è¿°ï¼š** è´Ÿè´£å®ç°ä¸»å¤‡åˆ‡æ¢é€»è¾‘ï¼Œä¸Redisäº¤äº’ã€‚
- **ä¸»è¦èŒè´£ï¼š**
    - **`HaSwitchLogic`:** (ç±»ä¼¼ `ms_switch.h` ä¸­çš„åŠŸèƒ½)
        - åˆå§‹åŒ–ï¼ˆ`switch_init`ï¼‰ï¼šåˆ¤æ–­åˆå§‹è§’è‰²ï¼ˆä¸»/å¤‡ï¼‰ï¼Œè¿æ¥Redisã€‚
        - å¿ƒè·³æœºåˆ¶ï¼šä¸»å®ä¾‹å®šæœŸå‘Rediså†™å…¥å¿ƒè·³ï¼›å¤‡å®ä¾‹ç›‘æ§å¿ƒè·³ã€‚
        - æ•…éšœæ£€æµ‹ï¼šå¤‡å®ä¾‹æ£€æµ‹åˆ°ä¸»å®ä¾‹å¿ƒè·³è¶…æ—¶ã€‚
        - åˆ‡æ¢æ‰§è¡Œï¼ˆ`switch_func`, `system_switch`ï¼‰ï¼š
            - å¤‡å®ä¾‹å°†è‡ªå·±æå‡ä¸ºä¸»ï¼Œæ›´æ–°Redisä¸­çš„ä¸»å®ä¾‹æ ‡è¯†ã€‚
            - ï¼ˆå¦‚æœéœ€è¦ï¼‰æ‰§è¡ŒIPæ¼‚ç§»ç­‰ç½‘ç»œé…ç½®å˜æ›´ã€‚
            - é€šçŸ¥å„æ ¸å¿ƒæ¨¡å—ï¼ˆå°¤å…¶æ˜¯ `SessionManager`ï¼‰ç³»ç»Ÿè§’è‰²å·²æ”¹å˜ã€‚
        - ä¿¡å·å¤„ç†ï¼šå“åº”å¤–éƒ¨ä¿¡å·ï¼ˆå¦‚ `SIGUSR1`, `SIGUSR2`ï¼‰è¿›è¡Œè§’è‰²åˆ‡æ¢æˆ–çŠ¶æ€ä¸ŠæŠ¥ã€‚
    - **`RedisClientInterface` (æˆ–ç›´æ¥ä½¿ç”¨ `hiredis` å°è£…):**
        - å°è£…ä¸RedisæœåŠ¡å™¨çš„è¿æ¥ã€å‘½ä»¤æ‰§è¡Œï¼ˆSET EX, GET, DEL, PUBLISH/SUBSCRIBEç­‰ï¼‰ã€‚
        - ä¾› `HaSwitchLogic` å’Œ `SessionManager` ç­‰æ¨¡å—ä½¿ç”¨ã€‚
    - **ä¸»è¦æ•°æ®ç»“æ„:** å½“å‰ç³»ç»Ÿè§’è‰²ï¼ˆä¸»/å¤‡ï¼‰ï¼Œå¯¹ç«¯å¿ƒè·³çŠ¶æ€ã€‚

#### 3.7. `logging/` - æ—¥å¿—æ¨¡å—

- **æ¦‚è¿°ï¼š** åŸºäº `spdlog` å®ç°å…¨å±€æ—¥å¿—è®°å½•ã€‚
- **ä¸»è¦èŒè´£ï¼š** åˆå§‹åŒ–æ—¥å¿—é…ç½®ï¼Œæä¾›å„çº§åˆ«æ—¥å¿—è®°å½•æ¥å£ã€‚

---

### 4. ä¸»è¦äº¤äº’æµç¨‹ç¤ºä¾‹ (ç®€è¿°)

1. **ZKå‘èµ·å‘¼å«ï¼š**
    - ZK -> `ZkInterface` (ZKç›‘å¬ç«¯å£) -> I/Oçº¿ç¨‹è¯»å– -> åˆæ­¥è§£æ -> ä»»åŠ¡å…¥é˜Ÿ
    - å·¥ä½œçº¿ç¨‹è·å–ä»»åŠ¡ -> `ZkInterface` (å¯é æ€§å¤„ç†ï¼Œå¦‚éœ€è¦) -> `Coordinator` -> `SessionManager` (åˆ›å»º`Session`å¯¹è±¡) -> `Session`å¯¹è±¡ (`onZkInitiateRequest`):
        - æ›´æ–°çŠ¶æ€ã€‚
        - è°ƒç”¨ `ConfigManager` è·å–é…ç½®ã€‚
        - è°ƒç”¨ `PortManager` åˆ†é…Bridgeåª’ä½“ç«¯å£ã€‚
        - **(HA)** å°†åˆå§‹ä¼šè¯ä¿¡æ¯å¼‚æ­¥å†™å…¥Redisã€‚
        - é€šè¿‡ `Coordinator` æŒ‡ç¤º `TmsInterface` å‘TMSå‘èµ·å‘¼å«ã€‚
        - é€šè¿‡ `Coordinator` æŒ‡ç¤º `ZkInterface` å›å¤ZKåˆæ­¥å“åº”ã€‚
2. **åª’ä½“æµå»ºç«‹ä¸è½¬å‘ï¼š**
    - `Session` å¯¹è±¡åœ¨æ”¶åˆ°TMSæ‘˜æœºå’Œåª’ä½“ç«¯å£ä¿¡æ¯åï¼š
        - æ›´æ–°çŠ¶æ€ã€‚
        - **(HA)** æ›´æ–°Redisä¸­çš„ä¼šè¯åª’ä½“ä¿¡æ¯ã€‚
        - è°ƒç”¨ `MediaRelay::setupFlow()` é…ç½®åŒå‘åª’ä½“è½¬å‘è§„åˆ™ã€‚
    - `MediaRelay` (å¯èƒ½åœ¨I/Oçº¿ç¨‹ä¸­):
        - æ”¶åˆ°ZKåª’ä½“ï¼ˆåœ¨ZKä¿¡ä»¤/åª’ä½“å…±äº«ç«¯å£ï¼Œéœ€æ ¹æ®åŒ…å†…ä¼šè¯IDæŸ¥æ‰¾è½¬å‘è¡¨ï¼‰ -> å»ZKåè®®å¤´ -> æŸ¥è½¬å‘è¡¨ -> åŠ TMSï¼ˆå¦‚æœ‰å¿…è¦ï¼‰æˆ–ç›´æ¥è½¬å‘ -> å‘é€ç»™TMSã€‚
        - æ”¶åˆ°TMSåª’ä½“ï¼ˆåœ¨Bridgeä¸ºè¯¥ä¼šè¯åˆ†é…çš„TMSåª’ä½“æ¥æ”¶ç«¯å£ï¼‰ -> æŸ¥è½¬å‘è¡¨ï¼ˆç”¨æœ¬åœ°ç«¯å£åšé”®ï¼‰-> åŠ ZKåè®®å¤´ -> å‘é€ç»™ZKï¼ˆä½¿ç”¨Bridgeä¸ºè¯¥ä¼šè¯åˆ†é…çš„å¯¹ZKå‘é€ç«¯å£ï¼‰ã€‚
3. **ä¸»å¤‡åˆ‡æ¢ï¼š**
    - `HaSwitchLogic` (å¤‡) æ£€æµ‹åˆ°ä¸»æ•…éšœ (å¦‚Rediså¿ƒè·³è¶…æ—¶)ã€‚
    - `HaSwitchLogic` (å¤‡) æ‰§è¡Œåˆ‡æ¢ï¼šæ›´æ–°Redisä¸»æ ‡è¯†ï¼Œ(å¯é€‰)IPæ¼‚ç§»ã€‚
    - `HaSwitchLogic` (å¤‡) é€šçŸ¥ `SessionManager` åŠ è½½æ´»åŠ¨ä¼šè¯ã€‚
    - `SessionManager` (æ–°ä¸») ä»Redisè¯»å–æ´»åŠ¨ä¼šè¯ä¿¡æ¯ï¼Œé‡å»ºè½»é‡çº§`Session`å¯¹è±¡æˆ–çŠ¶æ€ï¼Œå°è¯•æ¢å¤åª’ä½“è·¯å¾„ï¼ˆè¿™éƒ¨åˆ†è¾ƒå¤æ‚ï¼Œå¯èƒ½ç®€åŒ–ä¸ºé€šçŸ¥å¯¹ç«¯é‡é‚€æˆ–æ¸…ç†ï¼‰ã€‚

---

### 5. ç¬¬ä¸‰æ–¹åº“ä½¿ç”¨

- **Boost.Asio:** æ¨èç”¨äº `common/communication/` å®ç°å¼‚æ­¥ç½‘ç»œI/Oã€‚
- **nlohmann/json:** ç”¨äº `ConfigManager` è§£æJSONé…ç½®æ–‡ä»¶ã€‚
- **spdlog:** ç”¨äº `logging/` å®ç°æ—¥å¿—è®°å½•ã€‚
- **hiredis (Cå®¢æˆ·ç«¯):** ç”¨äº `RedisClientInterface` (æˆ–ç›´æ¥åœ¨ `HaSwitchLogic`, `SessionManager` ä¸­å°è£…) ä¸Redisé€šä¿¡ã€‚
- **(å¯é€‰) Google Test / Catch2:** ç”¨äºå•å…ƒæµ‹è¯•ã€‚

---

è¿™ä»½æ–‡æ¡£æä¾›äº†ä¸€ä¸ªæ›´å…¨é¢çš„ç»“æ„è®¾è®¡æ¡†æ¶ã€‚æ‚¨å¯ä»¥åŸºäºæ­¤ï¼Œé’ˆå¯¹æ¯ä¸ªæ¨¡å—è¿›ä¸€æ­¥ç»†åŒ–å…¶å†…éƒ¨ç±»è®¾è®¡ã€å‡½æ•°ç­¾åã€é”™è¯¯å¤„ç†ã€ä»¥åŠä¸å¤šçº¿ç¨‹ç›¸å…³çš„åŒæ­¥æœºåˆ¶ã€‚åœ¨å®ç°è¿‡ç¨‹ä¸­ï¼Œæ‚¨ä¼šä¸æ–­åœ°å›é¡¾å’Œè°ƒæ•´è¿™ä»½è®¾è®¡ã€‚ç¥æ‚¨é¡¹ç›®é¡ºåˆ©ï¼





[MODE: PLAN]

ç°åœ¨æˆ‘å°†åˆ›å»ºBridgeç³»ç»Ÿçš„è¯¦ç»†æŠ€æœ¯å®ç°è§„èŒƒã€‚åŸºäºæˆ‘ä»¬åœ¨RESEARCHå’ŒINNOVATEé˜¶æ®µçš„åˆ†æï¼Œæˆ‘å°†åˆ¶å®šå®Œæ•´çš„å¼€å‘è®¡åˆ’ã€‚

## é¡¹ç›®ç»“æ„è®¾è®¡

```
bridge_system/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ session_manager.h/cpp     # Sessionç®¡ç†æ ¸å¿ƒ
â”‚   â”‚   â”œâ”€â”€ config_manager.h/cpp      # é…ç½®æ–‡ä»¶ç®¡ç†
â”‚   â”‚   â””â”€â”€ port_pool.h/cpp           # ç«¯å£æ± ç®¡ç†
â”‚   â”œâ”€â”€ network/
â”‚   â”‚   â”œâ”€â”€ tcp_client.h/cpp          # TMS TCPå®¢æˆ·ç«¯
â”‚   â”‚   â”œâ”€â”€ tcp_server.h/cpp          # TMS TCPæœåŠ¡ç«¯
â”‚   â”‚   â”œâ”€â”€ udp_handler.h/cpp         # UDPå¤„ç†åŸºç±»
â”‚   â”‚   â””â”€â”€ socket_utils.h/cpp        # Socketå·¥å…·å‡½æ•°
â”‚   â”œâ”€â”€ protocol/
â”‚   â”‚   â”œâ”€â”€ tms_protocol.h/cpp        # TMSåè®®å¤„ç†
â”‚   â”‚   â”œâ”€â”€ zk_protocol.h/cpp         # ZKåè®®å¤„ç†
â”‚   â”‚   â””â”€â”€ message_types.h           # æ¶ˆæ¯ç±»å‹å®šä¹‰
â”‚   â”œâ”€â”€ media/
â”‚   â”‚   â”œâ”€â”€ media_relay.h/cpp         # åª’ä½“è½¬å‘æ ¸å¿ƒ
â”‚   â”‚   â””â”€â”€ media_thread.h/cpp        # åª’ä½“å¤„ç†çº¿ç¨‹
â”‚   â”œâ”€â”€ threads/
â”‚   â”‚   â”œâ”€â”€ signal_thread.h/cpp       # ä¿¡ä»¤å¤„ç†çº¿ç¨‹
â”‚   â”‚   â””â”€â”€ thread_manager.h/cpp      # çº¿ç¨‹ç®¡ç†
â”‚   â””â”€â”€ utils/
â”‚       â”œâ”€â”€ logger.h/cpp              # æ—¥å¿—ç³»ç»Ÿ
â”‚       â””â”€â”€ common_utils.h/cpp        # é€šç”¨å·¥å…·
â”œâ”€â”€ config/
â”‚   â””â”€â”€ bridge_config.ini             # ç³»ç»Ÿé…ç½®æ–‡ä»¶
â”œâ”€â”€ CMakeLists.txt                    # CMakeæ„å»ºæ–‡ä»¶
â”œâ”€â”€ README.md                         # é¡¹ç›®è¯´æ˜
â””â”€â”€ main.cpp                          # ä¸»ç¨‹åºå…¥å£
```

## æ ¸å¿ƒæ•°æ®ç»“æ„è®¾è®¡

### Sessionè¡¨ç»“æ„ (session_manager.h)
```cpp
struct SessionInfo {
    // å”¯ä¸€æ ‡è¯†
    std::string session_id;           // zk_ip + target_idç»„åˆ
    std::string zk_ip;
    std::string target_id;
    std::string cu_number;            // ç”µè¯å·ç 
    
    // ç«¯å£ä¿¡æ¯
    int bridge_tms_recv_port;         // Bridgeæ¥æ”¶TMSåª’ä½“ç«¯å£
    int bridge_zk_recv_port;          // Bridgeæ¥æ”¶ZKåª’ä½“ç«¯å£
    
    // åœ°å€ä¿¡æ¯
    struct sockaddr_in tms_send_addr; // TMSåª’ä½“å‘é€åœ°å€
    struct sockaddr_in zk_send_addr;  // ZKåª’ä½“å‘é€åœ°å€
    struct sockaddr_in zk_signal_addr;// ZKä¿¡ä»¤åœ°å€
    
    // ä¼šè¯çŠ¶æ€
    enum SessionState {
        IDLE, CALLING, ANSWERED, TALKING, HANGING, RELEASED
    } state;
    
    // ä¼šè¯ç±»å‹
    enum SessionType { P2P, CLUSTER } type;
    
    // åª’ä½“çº¿ç¨‹åˆ†é…
    int assigned_media_thread_id;     // åˆ†é…çš„åª’ä½“çº¿ç¨‹ID
    
    // çŠ¶æ€å˜æ›´å›è°ƒ
    std::function<void(SessionState, SessionState)> state_change_callback;
};
```

### åª’ä½“ç»‘å®šé…ç½®ç»“æ„ (media_relay.h)
```cpp
struct MediaBindingConfig {
    std::string session_id;
    int listen_port;                  // ç›‘å¬ç«¯å£
    struct sockaddr_in target_addr;   // è½¬å‘ç›®æ ‡åœ°å€
    int feedback_socket_fd;           // åé¦ˆsocketå¥æŸ„
    struct sockaddr_in feedback_addr; // åé¦ˆç›®æ ‡åœ°å€
    
    // é¢„ç¼–è¯‘çš„è½¬å‘å‡½æ•°æŒ‡é’ˆ
    std::function<void(const char*, size_t)> forward_function;
    std::function<void(const char*, size_t)> feedback_function;
};
```

## è¯¦ç»†å®ç°è§„èŒƒ

### 1. é…ç½®ç®¡ç†æ¨¡å— (config_manager.cpp)
```cpp
class ConfigManager {
private:
    // ZKé…ç½®åˆ—è¡¨
    struct ZKConfig {
        std::string zk_id;
        std::string ip;
        std::string bridge_ip;
        int port;
    };
    std::vector<ZKConfig> zk_configs;
    
    // Target_IDæ˜ å°„è¡¨
    std::unordered_map<std::string, std::string> target_cu_map;
    
    // ç«¯å£æ± é…ç½®
    int port_pool_start;
    int port_pool_end;
    
    // TMSæœåŠ¡å™¨é…ç½®
    std::string tms_server_ip;
    int tms_server_port;
    
    // BridgeæœåŠ¡å™¨é…ç½®
    std::string bridge_server_ip;
    int bridge_server_port;

public:
    bool load_config(const std::string& config_file);
    const std::vector<ZKConfig>& get_zk_configs() const;
    std::string get_cu_by_target_id(const std::string& target_id) const;
    std::pair<int, int> get_port_pool_range() const;
};
```

### 2. Sessionç®¡ç†å™¨æ ¸å¿ƒ (session_manager.cpp)
```cpp
class SessionManager {
private:
    // Sessionè¡¨ - å¤šé”®ç´¢å¼•
    std::unordered_map<std::string, SessionInfo> sessions_by_id;           // zk_ip+target_id
    std::unordered_map<std::string, SessionInfo*> sessions_by_cu;          // cuå·ç´¢å¼•
    std::unordered_map<int, SessionInfo*> sessions_by_tms_port;            // TMSç«¯å£ç´¢å¼•
    std::unordered_map<int, SessionInfo*> sessions_by_zk_port;             // ZKç«¯å£ç´¢å¼•
    
    PortPool port_pool;
    ConfigManager* config_manager;
    
    // åª’ä½“çº¿ç¨‹é€šä¿¡é˜Ÿåˆ—
    std::array<std::queue<MediaBindingConfig>, 4> media_thread_queues;
    std::array<std::mutex, 4> queue_mutexes;

public:
    // SessionæŸ¥æ‰¾æ–¹æ³•
    SessionInfo* find_session_by_cu(const std::string& cu);
    SessionInfo* find_session_by_id(const std::string& zk_ip, const std::string& target_id);
    SessionInfo* find_session_by_port(int port);
    
    // Sessionç”Ÿå‘½å‘¨æœŸç®¡ç†
    std::string create_session(const std::string& zk_ip, const std::string& target_id, SessionType type);
    void update_session_state(const std::string& session_id, SessionState new_state);
    void destroy_session(const std::string& session_id);
    
    // åª’ä½“é…ç½®æ¨é€
    void push_media_binding(const MediaBindingConfig& config);
    
    // çŠ¶æ€ä¸ŠæŠ¥
    void report_session_state_to_zk(const std::string& session_id);
    void report_all_sessions_to_zk(const std::string& zk_ip);
};
```

### 3. åè®®å¤„ç†æ¨¡å—

#### TMSåè®®å¤„ç† (tms_protocol.cpp)
```cpp
class TMSProtocol {
private:
    SessionManager* session_manager;
    
    // JSON-RPCå¤„ç†å‡½æ•°æ˜ å°„
    std::unordered_map<std::string, std::function<void(const json&)>> method_handlers;
    
    void handle_ringing(const json& params);
    void handle_paging(const json& params);
    void handle_answer(const json& params);
    void handle_hangup(const json& params);

public:
    void process_tms_message(const std::string& json_message);
    std::string create_call_request(const std::string& cu, int recv_port);
    std::string create_hangup_request(const std::string& cu);
};
```

#### ZKåè®®å¤„ç† (zk_protocol.cpp)
```cpp
class ZKProtocol {
private:
    SessionManager* session_manager;
    
    // ä¿¡ä»¤ç±»å‹å¤„ç†å‡½æ•°æ˜ å°„
    std::unordered_map<int, std::function<void(const ZKMessage&)>> signal_handlers;
    
    void handle_query_signal(const ZKMessage& msg);
    void handle_link_control_signal(const ZKMessage& msg);

public:
    void process_zk_message(const char* data, size_t len, const std::string& source_ip);
    std::string create_link_status_response(const SessionInfo& session);
    std::string create_media_feedback(const std::string& session_id, FeedbackType type);
};
```

### 4. åª’ä½“å¤„ç†çº¿ç¨‹ (media_thread.cpp)
```cpp
class MediaThread {
private:
    int thread_id;
    int feedback_socket_fd;           // SO_REUSEPORTä¸“ç”¨socket
    int epoll_fd;                     // epolläº‹ä»¶å¾ªç¯
    
    // é¢„ç»‘å®šé…ç½®å­˜å‚¨
    std::unordered_map<int, MediaBindingConfig> port_bindings;
    
    // é…ç½®æ¥æ”¶é˜Ÿåˆ—
    std::queue<MediaBindingConfig> config_queue;
    std::mutex config_mutex;

public:
    void initialize(int thread_id);
    void add_binding_config(const MediaBindingConfig& config);
    void run();                       // ä¸»äº‹ä»¶å¾ªç¯
    
private:
    void setup_feedback_socket();
    void handle_media_data(int port, const char* data, size_t len);
    void send_feedback(const std::string& session_id, FeedbackType type);
};
```

### 5. ä¿¡ä»¤å¤„ç†çº¿ç¨‹ (signal_thread.cpp)
```cpp
class SignalThread {
private:
    SessionManager session_manager;
    TMSProtocol tms_protocol;
    ZKProtocol zk_protocol;
    
    // ç½‘ç»œç»„ä»¶
    TCPClient tms_client;
    TCPServer tms_server;
    UDPHandler zk_handler;
    
    // å®šæ—¶å™¨
    std::timer status_report_timer;

public:
    void initialize();
    void run();                       // ä¸»äº‹ä»¶å¾ªç¯
    
private:
    void handle_tms_client_message(const std::string& message);
    void handle_tms_server_message(const std::string& message);
    void handle_zk_message(const char* data, size_t len, const std::string& source_ip);
    void periodic_status_report();
};
```

### 6. ç½‘ç»œç»„ä»¶å®ç°

#### TCPå®¢æˆ·ç«¯ (tcp_client.cpp)
```cpp
class TCPClient {
private:
    int socket_fd;
    struct sockaddr_in server_addr;
    bool connected;

public:
    bool connect_to_tms(const std::string& ip, int port);
    bool send_message(const std::string& message);
    std::string receive_message();
    void disconnect();
};
```

#### UDPå¤„ç†å™¨ (udp_handler.cpp)
```cpp
class UDPHandler {
private:
    int socket_fd;
    struct sockaddr_in bind_addr;

public:
    bool bind_port(const std::string& ip, int port);
    ssize_t send_to(const char* data, size_t len, const struct sockaddr_in& addr);
    ssize_t receive_from(char* buffer, size_t buffer_size, struct sockaddr_in& from_addr);
};
```

### 7. ä¸»ç¨‹åºå…¥å£ (main.cpp)
```cpp
int main(int argc, char* argv[]) {
    // 1. åŠ è½½é…ç½®æ–‡ä»¶
    ConfigManager config_manager;
    if (!config_manager.load_config("config/bridge_config.ini")) {
        return -1;
    }
    
    // 2. åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
    Logger::initialize("bridge_system.log");
    
    // 3. åˆ›å»ºå¹¶å¯åŠ¨ä¿¡ä»¤å¤„ç†çº¿ç¨‹
    SignalThread signal_thread;
    signal_thread.initialize();
    std::thread signal_worker(&SignalThread::run, &signal_thread);
    
    // 4. åˆ›å»ºå¹¶å¯åŠ¨4ä¸ªåª’ä½“å¤„ç†çº¿ç¨‹
    std::array<MediaThread, 4> media_threads;
    std::array<std::thread, 4> media_workers;
    
    for (int i = 0; i < 4; ++i) {
        media_threads[i].initialize(i);
        media_workers[i] = std::thread(&MediaThread::run, &media_threads[i]);
    }
    
    // 5. ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    signal_worker.join();
    for (auto& worker : media_workers) {
        worker.join();
    }
    
    return 0;
}
```

## é…ç½®æ–‡ä»¶æ ¼å¼ (bridge_config.ini)
```ini
[ZK_CONFIGS]
zk1=192.168.1.10,192.168.1.100,5001
zk2=192.168.1.11,192.168.1.100,5001
zk3=192.168.1.12,192.168.1.100,5002

[TARGET_MAPPING]
target001=12345678
target002=87654321

[PORT_POOL]
start_port=20000
end_port=25000

[TMS_SERVER]
ip=192.168.1.50
port=8080

[BRIDGE_SERVER]
ip=192.168.1.100
port=9090
```

## CMakeæ„å»ºé…ç½® (CMakeLists.txt)
```cmake
cmake_minimum_required(VERSION 3.16)
project(BridgeSystem)

set(CMAKE_CXX_STANDARD 17)

# æŸ¥æ‰¾ä¾èµ–åº“
find_package(PkgConfig REQUIRED)
pkg_check_modules(LIBJSONRPC REQUIRED libjsonrpc)

# è®¾ç½®æºæ–‡ä»¶
file(GLOB_RECURSE SOURCES "src/*.cpp")

# åˆ›å»ºå¯æ‰§è¡Œæ–‡ä»¶
add_executable(bridge_system ${SOURCES})

# é“¾æ¥åº“
target_link_libraries(bridge_system 
    ${LIBJSONRPC_LIBRARIES}
    pthread
)

# è®¾ç½®åŒ…å«ç›®å½•
target_include_directories(bridge_system PRIVATE 
    src/
    ${LIBJSONRPC_INCLUDE_DIRS}
)
```

## å®æ–½æ£€æŸ¥æ¸…å•

IMPLEMENTATION CHECKLIST:
1. åˆ›å»ºé¡¹ç›®ç›®å½•ç»“æ„å’ŒåŸºç¡€æ–‡ä»¶
2. å®ç°ConfigManagerç±»å’Œé…ç½®æ–‡ä»¶è§£æ
3. å®ç°PortPoolç«¯å£æ± ç®¡ç†ç±»
4. å®ç°SessionManageræ ¸å¿ƒç±»å’ŒSessionè¡¨ç®¡ç†
5. å®ç°TMSProtocolç±»å’ŒJSON-RPCæ¶ˆæ¯å¤„ç†
6. å®ç°ZKProtocolç±»å’ŒZKæ¶ˆæ¯å¤„ç†
7. å®ç°TCPClientç±»ç”¨äºTMSå®¢æˆ·ç«¯è¿æ¥
8. å®ç°TCPServerç±»ç”¨äºTMSæœåŠ¡ç«¯ç›‘å¬
9. å®ç°UDPHandlerç±»ç”¨äºZKé€šä¿¡
10. å®ç°MediaThreadç±»å’Œåª’ä½“å¤„ç†é€»è¾‘
11. å®ç°SignalThreadç±»å’Œä¿¡ä»¤å¤„ç†é€»è¾‘
12. å®ç°Loggeræ—¥å¿—ç³»ç»Ÿ
13. å®ç°ThreadManagerçº¿ç¨‹ç®¡ç†å™¨
14. ç¼–å†™main.cppä¸»ç¨‹åºå…¥å£
15. åˆ›å»ºCMakeLists.txtæ„å»ºé…ç½®
16. åˆ›å»ºbridge_config.inié…ç½®æ–‡ä»¶æ¨¡æ¿
17. ç¼–å†™README.mdé¡¹ç›®æ–‡æ¡£
18. é›†æˆlibjsonrpcåº“ä¾èµ–
19. å®ç°SO_REUSEPORT socketé…ç½®
20. å®ç°é¢„ç»‘å®šåª’ä½“è½¬å‘æœºåˆ¶
21. å®ç°çŠ¶æ€ä¸ŠæŠ¥å’Œåé¦ˆæœºåˆ¶
22. å®ç°ä¼šè¯ç”Ÿå‘½å‘¨æœŸç®¡ç†
23. å®ç°å¤šé”®ç´¢å¼•çš„SessionæŸ¥æ‰¾
24. å®ç°åª’ä½“çº¿ç¨‹çš„é…ç½®æ¥æ”¶æœºåˆ¶
25. å®Œæˆç³»ç»Ÿé›†æˆæµ‹è¯•
