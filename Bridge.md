#### 系统概述：
	存在实体 tms，和zk，其中zk有1-10个。而tms有一个。 zk和tms有各自的协议，所以当zk要和tms沟通时需要一个中间桥梁程序 ：Bridge

#### 主要核心场景：

启动阶段 

  

配置加载，读取tms, zhs ip port 列表， 读取cu和target_id映射配置和Cu专项配置 建立连接 进行监听 ·
zk发起通告需求 ·
brdige解析通告需求，提取target_id,等参数 
由于站控很多所以肯定要想办法来标识 会话和站控之间的关系,分配次此些被叫终端和指定站控这两个唯一标定的会话的业务端口 media_port brdige回复点对点状态 ·此时需要记录状态变量，并且通过tms和cu的交互来及时更新状态变量 ·通过目的终端来找到对应的cu号，然后对每个cu号可能有特定的配置项。查询会话映射表以 及cu配置文件，分配向tms的业务端口构建实体2的发起呼叫信令 同时向tms发起呼叫，通过读取配置文件和解析的通告需求参数 这时需要配置个向tms的 业务端口 需要向tms发送发起呼叫信令 其中发送速率按信道带宽来换算 接收速率应该根据当前负载情况来定吧， 操作者地址如何处理? 和tms交互信令同时更新上报给实体2的点对点状态 当收到摘机信令时，上报状态变为键链成功 ·解析摘机信令，从其中获取tms向brdige的业务端口 ·建立业务udp 等待业务数据 准备进行转发 业务数据到来时，通过业务端口到会话表中查找会话， 添加固定字段 包装为 实体2认识的格式 通过会话表找到brdige->zk udp port并转发 ·如果zk->brdige收到业务数据 由通道号找到会话表，由会话表查找转发给tms的端口或者说是调用的socket? ·去除字段然后发送转给tms 关闭阶段 ·实体2发送通告拆链 关闭阶段  

  

实体2发送通告拆链  


解析拆链消息  

  

提取目的终端,通过目的终端和站控id来查找会话  

  

更新会话状态为正在关闭  

  

通过session数据结构 访问其中的cu号来向tms发送呼叫挂断  

  

·收到呼叫挂断响应  

  

·通过cu号来查找session结构体并更新其中的状态  

  

更新session数据结构中的状态  

  

回收brdige->tms业务udp端口及socket，回收brdige->zkudp端口和socket  

  

更新session中状态为已经拆链  

  

释放session数据结构 请你设计一个架构 我内心已经有一个架构了 我想和你比一下谁设计的更好

#### 结构设计：
- zk_interface: 负责zk协议的数据结构实现，以及这些数据结构的方法，创建方法和解析方法
