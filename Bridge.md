#### ç³»ç»Ÿæ¦‚è¿°ï¼š
	å­˜åœ¨å®ä½“ tmsï¼Œå’Œzkï¼Œå…¶ä¸­zkæœ‰1-10ä¸ªã€‚è€Œtmsæœ‰ä¸€ä¸ªã€‚ zkå’Œtmsæœ‰å„è‡ªçš„åè®®ï¼Œæ‰€ä»¥å½“zkè¦å’Œtmsæ²Ÿé€šæ—¶éœ€è¦ä¸€ä¸ªä¸­é—´æ¡¥æ¢ç¨‹åº ï¼šBridge

#### ä¸»è¦æ ¸å¿ƒåœºæ™¯ï¼š

- æ”¶åˆ°zkå‘èµ·é€šå‘Šéœ€æ±‚ 
- brdigeè§£æé€šå‘Šéœ€æ±‚ï¼Œæå–target_id,ç­‰å‚æ•° 
- è½¬å‘é€šå‘Šéœ€æ±‚åˆ°tms
- å’Œtmså®Œæˆä¼šè¯ä¿¡ä»¤äº¤äº’è¿‡ç¨‹ ï¼ŒæˆåŠŸè¿›å…¥ä¸šåŠ¡é€šä¿¡
- å°†æ”¶åˆ°çš„zkçš„ä¸šåŠ¡é€šä¿¡ï¼Œè½¬å‘åˆ°å¯¹åº”çš„tmsä¾§çš„ç»ˆç«¯
- å°†æ”¶åˆ°çš„tmsä¾§çš„ä¸šåŠ¡é€šä¿¡è½¬å‘åˆ°å¯¹åº”çš„zk

- æ”¶åˆ°zk æ‹†é“¾é€šå‘Šéœ€æ±‚
- bridge è½¬å‘æ­¤éœ€æ±‚åˆ°tms
- tmså’Œbridgeæ‹†é“¾ä¿¡ä»¤äº¤äº’
- ä¸šåŠ¡é€šä¿¡æ‹†é™¤


##### è¯¦ç»†æ ¸å¿ƒåœºæ™¯æµç¨‹
- ç¨‹åºå¯åŠ¨
	- ä»é…ç½®æ–‡ä»¶ä¸­åŠ è½½cué…ç½®è¡¨ï¼Œcuå’Œtarget_idæ˜ å°„è¡¨
	-  åŠ è½½tms,zk çš„ip port åŒæ—¶å¯åŠ¨ç›‘å¬æµç¨‹
	- å’Œtmså»ºç«‹å¿ƒè·³ï¼Œå½“å­˜åœ¨å¿ƒè·³æ—¶ï¼Œä¸ŠæŠ¥è®¾å¤‡çŠ¶æ€åˆ°zk
- ç¨‹åºè¿è¡Œï¼š
	- ç›‘å¬åˆ°æ¥è‡ªzkçš„æŠ¥æ–‡
	- è¿™é‡Œå¥½åƒåè®®è‡ªå·±å°è£…äº†å¯é æ€§æœºåˆ¶
	- åˆ¤æ–­ç±»å‹ä¸º éœ€æ±‚é€šå‘Š
	- åˆ¤æ–­å†…å®¹ä¸ºå»ºç«‹ç‚¹å¯¹ç‚¹é€šä¿¡
	- æå–è¢«å«å·ç ï¼Œå¸¦å®½
	- é€šè¿‡å·ç  è¯»å–ç›¸åº”é…ç½®
	- åˆ›å»ºç‚¹å¯¹ç‚¹ä¼šè¯è¡¨ï¼Œå¹¶å¡«å…¥zk_ipï¼Œè¢«å«å·ç ï¼Œå¸¦å®½ï¼Œé…ç½®ï¼Œè‡ªåŠ¨åˆ†é… bridge->zk ä¸šåŠ¡ç«¯å£ï¼Œbridge->tmsä¸šåŠ¡ç«¯å£
	- ä¼šè¯è¡¨è§¦å‘tmsä¾§å‘èµ·å‘¼å«
	- é€šè¿‡tcpå‘é€
	- æ¥æ”¶tcpå“åº”ï¼Œæ›´æ–°ä¼šè¯è¡¨çŠ¶æ€
	- ä¼šè¯è¡¨æ£€æµ‹åˆ°ä¹‹å
	- è§£æä¸šåŠ¡ç«¯å£ï¼Œæ›´æ–°åˆ°ä¼šè¯è¡¨ä¸­
    - 

å®ä½“2å‘é€é€šå‘Šæ‹†é“¾Â Â 


è§£ææ‹†é“¾æ¶ˆæ¯Â Â 

  

æå–ç›®çš„ç»ˆç«¯,é€šè¿‡ç›®çš„ç»ˆç«¯å’Œç«™æ§idæ¥æŸ¥æ‰¾ä¼šè¯Â Â 

  

æ›´æ–°ä¼šè¯çŠ¶æ€ä¸ºæ­£åœ¨å…³é—­Â Â 

  

é€šè¿‡sessionæ•°æ®ç»“æ„ è®¿é—®å…¶ä¸­çš„cuå·æ¥å‘tmså‘é€å‘¼å«æŒ‚æ–­Â Â 

  

Â·æ”¶åˆ°å‘¼å«æŒ‚æ–­å“åº”Â Â 

  

Â·é€šè¿‡cuå·æ¥æŸ¥æ‰¾sessionç»“æ„ä½“å¹¶æ›´æ–°å…¶ä¸­çš„çŠ¶æ€Â Â 

  

æ›´æ–°sessionæ•°æ®ç»“æ„ä¸­çš„çŠ¶æ€Â Â 

  

å›æ”¶brdige->tmsä¸šåŠ¡udpç«¯å£åŠsocketï¼Œå›æ”¶brdige->zkudpç«¯å£å’ŒsocketÂ Â 

  

æ›´æ–°sessionä¸­çŠ¶æ€ä¸ºå·²ç»æ‹†é“¾Â Â 

  

é‡Šæ”¾sessionæ•°æ®ç»“æ„ è¯·ä½ è®¾è®¡ä¸€ä¸ªæ¶æ„ æˆ‘å†…å¿ƒå·²ç»æœ‰ä¸€ä¸ªæ¶æ„äº† æˆ‘æƒ³å’Œä½ æ¯”ä¸€ä¸‹è°è®¾è®¡çš„æ›´å¥½

#### ç»“æ„è®¾è®¡ï¼š
- zk_interface: è´Ÿè´£zkåè®®çš„æ•°æ®ç»“æ„å®ç°ï¼Œä»¥åŠè¿™äº›æ•°æ®ç»“æ„çš„æ–¹æ³•ï¼Œåˆ›å»ºæ–¹æ³•å’Œè§£ææ–¹æ³•



ubuntu16.04 è™šæ‹Ÿæœºé•œåƒ å¯†ç  1234



FROM ubuntu:20.04

# é¿å…äº¤äº’å¼å®‰è£…

ENV DEBIAN_FRONTEND=noninteractive

# å®‰è£…å¼€å‘å·¥å…·

RUN apt-get update && apt-get install -y \

build-essential \

cmake \

gdb \

git \

curl \

wget \

vim \

nano \

pkg-config \

valgrind \

&& rm -rf /var/lib/apt/lists/*

# åˆ›å»ºå¼€å‘ç”¨æˆ·

RUN useradd -m -s /bin/bash developer && \

usermod -aG sudo developer && \

echo 'developer:developer' | chpasswd && \

echo 'developer ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers

# è®¾ç½®å·¥ä½œç›®å½•

WORKDIR /workspace

# åˆ‡æ¢åˆ°å¼€å‘ç”¨æˆ·

USER developer

# è®¾ç½®ç¼–è¯‘ç¯å¢ƒå˜é‡ï¼ˆå…¼å®¹æ€§ä¼˜å…ˆï¼‰

ENV CXXFLAGS="-std=c++11"

ENV CC=gcc

ENV CXX=g++

è¿™æ˜¯æˆ‘çš„docker fileæ–‡ä»¶ æ¯æ¬¡æˆ‘è¿›å»è¿™ä¸ªå·¥ç¨‹ éƒ½æç¤ºæˆ‘è¦å®‰è£… æ’ä»¶ ä½†æ˜¯å®‰è£…å®Œä»¥å å½“æˆ‘è¿æ¥è¿™äº›å®¹å™¨ æ—¶ åˆæç¤ºæˆ‘ osç‰ˆæœ¬å¤ªè€äº† ä½†æ˜¯æˆ‘è§‰å¾— ä¸å¤ªå¯¹ï¼Œå› ä¸ºæˆ‘çš„é•œåƒæ˜¯20.04çš„ä¸å¯èƒ½æ˜¯è¿™ä¸ªåŸå›  æˆ‘çš„ç†è§£å°±æ˜¯è¿æ¥æ—¶ è¿æ¥åˆ°äº†é”™è¯¯çš„å®¹å™¨ ä¸Š ä½†æ˜¯å¥½åƒå·¥ç¨‹ä¸‹çš„æœ‰ä¸¤ä¸ªé…ç½®æ–‡ä»¶ ä¸€ä¸ªdevcontainer.json ä¸€ä¸ªdockerfile æˆ‘ç°åœ¨éœ€è¦å¼„æ¸…æ¥šä¸€äº›åŸºæœ¬çš„æ¦‚å¿µ ï¼Œ ä½ æ¥å‘Šè¯‰æˆ‘è¿™ä¸¤ä¸ªé…ç½®æ–‡ä»¶ æ˜¯å¹²å˜›ç”¨çš„ ï¼Œè°¢è°¢Â 

è€Œä¸”ç”±äºæˆ‘æƒ³åœ¨è¿™ä¸ªdockeré‡Œä½¿ç”¨äº¤å‰ç¼–è¯‘






Okay, here's a structural design document for your C++ "Bridge" application, incorporating our discussions on I/O multiplexing, event-driven architecture, and multithreading. I'll also address your question about using JSON, spdlog, and Redis.

Yes, you absolutely **should consider using libraries like a JSON parser, spdlog, and Redis**, especially given your requirements:

- **JSON Library (e.g., nlohmann/json, RapidJSON):** Excellent for reading configuration files if they are in JSON format. This simplifies configuration management significantly.
- **spdlog:** A very good choice for high-performance, flexible, and structured logging in C++. Logging is crucial for debugging and monitoring any server application.
- **Redis:** Forä¸»å¤‡å®¹ç¾ (active-standby disaster recovery), Redis is a strong candidate. It can be used to store and replicate active session state. If a primary Bridge instance fails, a standby instance can potentially take over by loading session information from Redis, allowing for more seamless failover or graceful termination of existing calls.

---

## Bridge ç³»ç»Ÿç»“æ„è®¾è®¡è¯´æ˜æ–‡æ¡£

æœ¬æ–‡æ¡£æè¿°äº† Bridge ç³»ç»Ÿçš„ç»“æ„è®¾è®¡ï¼Œè¯¥ç³»ç»Ÿä½œä¸º ZK å®ä½“å’Œ TMS ç³»ç»Ÿä¹‹é—´çš„ä¸­é—´æ¡¥æ¢ï¼Œæ”¯æŒä¿¡ä»¤å’Œåª’ä½“ä¸šåŠ¡çš„è½¬å‘ã€‚è®¾è®¡è€ƒè™‘äº†é«˜æ€§èƒ½ã€é«˜å¹¶å‘ã€å¯æ‰©å±•æ€§å’Œå¯ç»´æŠ¤æ€§ï¼Œé‡‡ç”¨äº†I/Oå¤ç”¨ã€äº‹ä»¶é©±åŠ¨å’Œå¤šçº¿ç¨‹çš„æ¶æ„ã€‚

---

### 1. æ ¸å¿ƒè®¾è®¡åŸåˆ™ ğŸŒŸ

- **æ¨¡å—åŒ–:** ç³»ç»Ÿåˆ’åˆ†ä¸ºå…·æœ‰æ˜ç¡®èŒè´£çš„ç‹¬ç«‹æ¨¡å—ã€‚
- **å¼‚æ­¥éé˜»å¡:** I/Oæ“ä½œå’Œæ ¸å¿ƒé€»è¾‘é‡‡ç”¨å¼‚æ­¥éé˜»å¡æ¨¡å¼ï¼Œä»¥æé«˜å¹¶å‘å¤„ç†èƒ½åŠ›ã€‚
- **äº‹ä»¶é©±åŠ¨:** ç³»ç»Ÿç”±å¤–éƒ¨äº‹ä»¶ï¼ˆå¦‚ç½‘ç»œæ¶ˆæ¯ã€å®šæ—¶å™¨ï¼‰å’Œå†…éƒ¨äº‹ä»¶ï¼ˆä»»åŠ¡å®Œæˆï¼‰é©±åŠ¨ã€‚
- **çº¿ç¨‹åˆ†ç¦»:** I/Oå¯†é›†å‹ä»»åŠ¡ä¸CPUå¯†é›†å‹ï¼ˆæˆ–ä¸šåŠ¡é€»è¾‘ï¼‰ä»»åŠ¡ç”±ä¸åŒç±»å‹çš„çº¿ç¨‹å¤„ç†ã€‚
- **ä¼šè¯ä¸­å¿ƒåŒ–:** `Session` å¯¹è±¡å°è£…äº†å•ä¸ªç«¯åˆ°ç«¯å‘¼å«çš„æ ¸å¿ƒçŠ¶æ€å’Œé€»è¾‘ã€‚
- **çº¿ç¨‹å®‰å…¨:** æ‰€æœ‰å…±äº«èµ„æºï¼ˆä¼šè¯è¡¨ã€ç«¯å£æ± ã€åª’ä½“è½¬å‘è¡¨ç­‰ï¼‰çš„è®¾è®¡éƒ½å¿…é¡»è€ƒè™‘çº¿ç¨‹å®‰å…¨ã€‚

---

### 2. æ€»ä½“æ¶æ„å›¾ (æ¦‚å¿µ)

```
+---------------------+      +-----------------------+      +---------------------+
|     ZK Entities     |<---->|      ZK Interface     |<---->|                     |
| (10 ZKs, 1 port ea. |      | (10 Listeners,        |      |                     |
|  Signaling & Media) |      |  Demux, Proto Handler) |      |   Coordinator /   |
+---------------------+      +-----------+-----------+      |   Event Router    |      +-------------------+
                                         ^                          |                     |----->|  Session Module   |
                                         |                          v                     |<-----| (SessionManager,  |
                                         | (Tasks)           +------+------+              |      |  Session Objects) |
                                         |                   | Task Queue  |              |      +-------------------+
                                         v                   +------+------+              |                |
+---------------------+      +-----------+-----------+              | (Tasks)            |                | (Config MediaRelay)
|     TMS System      |<---->|     TMS Interface     |<-------------+                     |                v
| (1 TCP Sig, N UDP   |      | (TCP Conn, N UDP Listen,|             v                     |      +-------------------+
|  Media from TMS)    |      |  Proto Handler)       |      +-----------------------+      |----->| MediaRelay Module |
+---------------------+      +-----------------------+      |   Worker Thread Pool  |------      |(Fast Fwd Table,   |
                                                            +-----------------------+             | Header Manip.)    |
                                                                                                  +-------------------+
                                                                     |  ^
                                                                     |  | (Alloc/Release)
                                                                     v  |
+-----------------------+     +-----------------------+     +-----------------------+
| Communication Layer   |<--->|    Protocol Layer     |<--->|    Port Manager       |
| (Async Sockets)       |     | (ZK/TMS Parsers/Fmts) |     | (UDP Port Pool)       |
+-----------------------+     +-----------------------+     +-----------------------+

+-----------------------+     +-----------------------+
| Configuration Manager |     |     Logging (spdlog)  |
| (JSON for config)     |     +-----------------------+
+-----------------------+

+-----------------------+
| Redis (Optional for HA|
| Session State Sync)   |
+-----------------------+
```

---

### 3. çº¿ç¨‹æ¨¡å‹ ğŸ§µ

- **I/O çº¿ç¨‹ (å°‘é‡, e.g., `num_cores / 2` æˆ– `num_cores`):**
    - è¿è¡Œ `epoll` (æˆ–ç­‰æ•ˆçš„) äº‹ä»¶å¾ªç¯ã€‚
    - è´Ÿè´£æ‰€æœ‰Socketçš„éé˜»å¡è¯»å†™ã€‚
    - è¿›è¡Œæœ€åŸºæœ¬çš„æ•°æ®åŒ…è§£æï¼ˆå¦‚è¯†åˆ«æ¥æºã€åˆ¤æ–­æ˜¯ä¿¡ä»¤è¿˜æ˜¯åª’ä½“ï¼Œæå–ä¼šè¯æ ‡è¯†ç¬¦ï¼‰ã€‚
    - å°†è§£æåçš„ä»»åŠ¡ï¼ˆå°è£…äº†æ•°æ®å’Œä¸Šä¸‹æ–‡ï¼‰æ”¾å…¥ä»»åŠ¡é˜Ÿåˆ—ï¼Œäº¤ç”±å·¥ä½œçº¿ç¨‹æ± å¤„ç†ã€‚
    - ç›´æ¥å¤„ç†æä½å»¶è¿Ÿçš„åª’ä½“è½¬å‘ï¼ˆå¦‚æœåŒ…å¤´æ“ä½œç®€å•ï¼‰ã€‚
- **å·¥ä½œçº¿ç¨‹æ±  (å›ºå®šæ•°é‡, e.g., `num_cores` æˆ–æ›´å¤š):**
    - ä»ä»»åŠ¡é˜Ÿåˆ—ä¸­è·å–ä»»åŠ¡ã€‚
    - æ‰§è¡Œæ‰€æœ‰æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ï¼š`Session` å¯¹è±¡çš„åˆ›å»ºã€çŠ¶æ€æ›´æ–°ã€å†³ç­–ï¼›ä¸ `ConfigManager`ã€`PortManager` äº¤äº’ï¼›å‡†å¤‡ä¿¡ä»¤æ•°æ®ï¼›é€šè¿‡ `Coordinator` æŒ‡ç¤ºæ¥å£å±‚å‘é€æ¶ˆæ¯ï¼›é…ç½® `MediaRelay`ã€‚
- **å¯é€‰çš„ä¸“ç”¨çº¿ç¨‹ï¼š**
    - TMSå¿ƒè·³çº¿ç¨‹ã€‚
    - å®šæ—¶æ¸…ç†çº¿ç¨‹ (å¦‚æ¸…ç†è¿‡æœŸä¼šè¯)ã€‚

---

### 4. ä»£ç ç»“æ„ä¸æ¨¡å—è¯´æ˜

```
bridge_system/
â”œâ”€â”€ main.cpp                     # ç¨‹åºå…¥å£, åˆå§‹åŒ–å„æ¨¡å—, å¯åŠ¨I/Oäº‹ä»¶å¾ªç¯å’Œå·¥ä½œçº¿ç¨‹æ± 
â”‚
â”œâ”€â”€ common/                      # é€šç”¨åŸºç¡€æ¨¡å—
â”‚   â”œâ”€â”€ communication/           # åº•å±‚å¼‚æ­¥ç½‘ç»œé€šä¿¡å°è£…
â”‚   â”‚   â”œâ”€â”€ async_udp_socket.{h,cpp}
â”‚   â”‚   â””â”€â”€ async_tcp_client.{h,cpp} # (å¦‚æœTMSä¿¡ä»¤æ˜¯Clientæ¨¡å¼)
â”‚   â”‚   â””â”€â”€ async_tcp_server.{h,cpp} # (å¦‚æœTMSä¿¡ä»¤æ˜¯Serveræ¨¡å¼æˆ–ç®¡ç†æ¥å£)
â”‚   â”œâ”€â”€ task_queue/              # çº¿ç¨‹å®‰å…¨çš„ä»»åŠ¡é˜Ÿåˆ— (I/Oçº¿ç¨‹ä¸å·¥ä½œçº¿ç¨‹äº¤äº’)
â”‚   â”‚   â””â”€â”€ concurrent_queue.h
â”‚   â””â”€â”€ utils/                   # å…¶ä»–å·¥å…·ç±» (e.g., string manipulation, timers)
â”‚       â””â”€â”€ ...
â”‚
â”œâ”€â”€ protocols/                   # åè®®å®šä¹‰ä¸ç¼–è§£ç  (æ— çŠ¶æ€å·¥å…·åº“)
â”‚   â”œâ”€â”€ zk_protocol/
â”‚   â”‚   â”œâ”€â”€ zk_message_types.h   # ZKåè®®æ¶ˆæ¯çš„C++ç»“æ„ä½“å®šä¹‰
â”‚   â”‚   â”œâ”€â”€ zk_parser.{h,cpp}    # è§£æZKå­—èŠ‚æµ -> ç»“æ„ä½“
â”‚   â”‚   â””â”€â”€ zk_formatter.{h,cpp} # ç»“æ„ä½“ -> ZKå­—èŠ‚æµ
â”‚   â””â”€â”€ tms_protocol/
â”‚       â”œâ”€â”€ tms_message_types.h
â”‚       â”œâ”€â”€ tms_parser.{h,cpp}
â”‚       â””â”€â”€ tms_formatter.{h,cpp}
â”‚
â”œâ”€â”€ interfaces/                  # å¤–éƒ¨ç³»ç»Ÿæ¥å£é€‚é…å±‚
â”‚   â”œâ”€â”€ zk_interface/
â”‚   â”‚   â”œâ”€â”€ zk_listener.{h,cpp}  # ç®¡ç†10ä¸ªUDPç›‘å¬Socket (æ¥æ”¶ZKä¿¡ä»¤å’Œåª’ä½“)
â”‚   â”‚   â”‚                        # åŠŸèƒ½: ä½¿ç”¨communicationå±‚, æ³¨å†Œåˆ°epoll, è¯»å–æ•°æ®,
â”‚   â”‚   â”‚                        #       åˆæ­¥è§£æ(è¯†åˆ«ZK ID, ä¼šè¯ID, ä¿¡ä»¤/åª’ä½“),
â”‚   â”‚   â”‚                        #       åˆ›å»ºä»»åŠ¡å¹¶æ”¾å…¥TaskQueueæˆ–ç›´æ¥è°ƒç”¨MediaRelay
â”‚   â”‚   â”œâ”€â”€ zk_sender.{h,cpp}    # å°è£…å‘ZKå‘é€æ•°æ® (ä½¿ç”¨communicationå±‚å’Œzk_formatter)
â”‚   â”‚   â””â”€â”€ zk_defs.h            # ZKæ¥å£ç›¸å…³çš„å†…éƒ¨å¸¸é‡/å®šä¹‰
â”‚   â””â”€â”€ tms_interface/
â”‚       â”œâ”€â”€ tms_connector.{h,cpp}# ç®¡ç†ä¸TMSçš„TCPä¿¡ä»¤è¿æ¥ (å¿ƒè·³, æ”¶å‘)
â”‚       â”œâ”€â”€ tms_media_listener.{h,cpp} # ç®¡ç†Nä¸ªUDPç›‘å¬Socket (æ¥æ”¶TMSåª’ä½“)
â”‚       â”œâ”€â”€ tms_sender.{h,cpp}   # å°è£…å‘TMSå‘é€æ•°æ®
â”‚       â””â”€â”€ tms_defs.h
â”‚
â”œâ”€â”€ core_logic/                  # æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
â”‚   â”œâ”€â”€ coordinator.{h,cpp}      # åè°ƒå™¨/è·¯ç”±å™¨: åœ¨æ¥å£å±‚å’Œä¼šè¯æ¨¡å—é—´ä¼ é€’äº‹ä»¶å’ŒæŒ‡ä»¤
â”‚   â”‚                            # åŠŸèƒ½: ç”±å·¥ä½œçº¿ç¨‹è°ƒç”¨, è·¯ç”±åˆ°SessionManageræˆ–å…·ä½“Session
â”‚   â”œâ”€â”€ session.h                # Sessionå¯¹è±¡å®šä¹‰
â”‚   â”‚   â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: SessionState (enum), ZK/TMSåª’ä½“ä¿¡æ¯,
â”‚   â”‚   â”‚                        #               ä¼šè¯ID, target_id, å¸¦å®½, Cué…ç½®å¼•ç”¨ç­‰
â”‚   â”‚   â”‚                        # ä¸»è¦å‡½æ•°: handleZkEvent(), handleTmsEvent(),
â”‚   â”‚   â”‚                        #           processMedia(), setupMediaRelayRules(),
â”‚   â”‚   â”‚                        #           initiateTmsCall(), sendStateToZk(), cleanup()
â”‚   â”œâ”€â”€ session.cpp              # Sessionå¯¹è±¡å®ç° (çŠ¶æ€æœº, æ ¸å¿ƒä¸šåŠ¡æµç¨‹)
â”‚   â”œâ”€â”€ session_manager.h        # SessionManagerç±»å®šä¹‰ (çº¿ç¨‹å®‰å…¨)
â”‚   â”‚   â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: std::unordered_map<SessionID, std::shared_ptr<Session>> active_sessions;
â”‚   â”‚   â”‚                        #               (å¯èƒ½è¿˜æœ‰å…¶ä»–ç´¢å¼•map, å¦‚ Port -> SessionID)
â”‚   â”‚   â”‚                        # ä¸»è¦å‡½æ•°: createSession(), findSession(), removeSession()
â”‚   â”œâ”€â”€ session_manager.cpp      # SessionManagerå®ç°
â”‚   â”œâ”€â”€ port_manager.h           # PortManagerç±»å®šä¹‰ (çº¿ç¨‹å®‰å…¨)
â”‚   â”‚   â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: std::set<uint16_t> available_ports; std::mutex mtx;
â”‚   â”‚   â”‚                        # ä¸»è¦å‡½æ•°: allocatePort(), releasePort()
â”‚   â”œâ”€â”€ port_manager.cpp         # PortManagerå®ç°
â”‚   â””â”€â”€ config_manager.h         # ConfigManagerç±»å®šä¹‰
â”‚       â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: Structs for ZK/TMS config, CU config table,
â”‚       â”‚                        #               CU-target_id map. (ä½¿ç”¨JSONåº“è§£æ)
â”‚       â”‚                        # ä¸»è¦å‡½æ•°: loadConfigs(), getZkConfig(zkId), getTmsConfig(),
â”‚       â”‚                        #           getCuConfig(cuId), getTargetCuMapping(targetId)
â”‚   â””â”€â”€ config_manager.cpp       # ConfigManagerå®ç°
â”‚
â”œâ”€â”€ media_processing/            # åª’ä½“å¤„ç†ä¸è½¬å‘
â”‚   â””â”€â”€ media_relay.{h,cpp}      # åª’ä½“ä¸­ç»§æ¨¡å— (çº¿ç¨‹å®‰å…¨)
â”‚       â”‚                        # ä¸»è¦æ•°æ®ç»“æ„: ForwardingRule (åŒ…å«ç›®æ ‡IP/Port, åŒ…å¤´å¤„ç†å‡½æ•°æŒ‡é’ˆ/lambda, å‘é€Socketå¼•ç”¨)
â”‚       â”‚                        #               std::unordered_map<uint16_t /*local_rcv_port*/, ForwardingRule> zk_to_tms_flows;
â”‚       â”‚                        #               std::unordered_map<uint16_t /*local_rcv_port*/, ForwardingRule> tms_to_zk_flows;
â”‚       â”‚                        # ä¸»è¦å‡½æ•°: setupFlow(), teardownFlow(),
â”‚       â”‚                        #           processIncomingZkMedia(packet, local_port_or_session_id),
â”‚       â”‚                        #           processIncomingTmsMedia(packet, local_port)
â”‚
â””â”€â”€ logging/                     # æ—¥å¿—æ¨¡å—
    â””â”€â”€ logger_wrapper.{h,cpp}   # spdlogçš„å°è£…å’Œå…¨å±€è®¿é—®ç‚¹
```

---

### 5. å…³é”®æ•°æ®ç»“æ„ä¸å‡½æ•°æ¦‚è¿° (éƒ¨åˆ†å·²åœ¨ä¸Šé¢æåŠ)

- **`Session` å¯¹è±¡:**
    - **æ•°æ®:** `sessionId`, `zkId`, `targetId`, `bandwidth`, `zkAllocatedBridgeMediaPort` (ç”¨äºå‘å¾€ZK), `tmsAllocatedBridgeMediaPort` (ç”¨äºæ”¶å‘TMSåª’ä½“), `tmsRemoteMediaEndpoint`, `cuConfig`, `currentState (enum: IDLE, ZK_INITIATED, TMS_CONNECTING, ACTIVE, TERMINATING, ...)`ã€‚
    - **å‡½æ•°:** `handleZkSignaling(parsedMsg)`, `handleTmsSignaling(parsedMsg)`, `allocateMediaPorts()`, `setupMediaRelay()`, `sendToZkViaCoordinator(msg)`, `sendToTmsViaCoordinator(msg)`, `terminate()`.
- **`SessionManager`:**
    - **æ•°æ®:** `std::unordered_map<std::string /*SessionID*/, std::shared_ptr<Session>> sessions_by_id;` (ä¸»è¡¨ï¼Œçº¿ç¨‹å®‰å…¨), å¯èƒ½è¿˜æœ‰å…¶ä»–è¾…åŠ©ç´¢å¼•è¡¨å¦‚ `std::unordered_map<uint16_t /*BridgeLocalMediaPort*/, std::string /*SessionID*/> port_to_session_map;` (ç”¨äºåª’ä½“åŒ…åˆæ¬¡å…³è”ï¼Œä½†åç»­åª’ä½“è½¬å‘ä¸ä¾èµ–å®ƒ)ã€‚
    - **å‡½æ•°:** `createSessionFromZk(zkData)`, `getSessionById(id)`, `getSessionByLocalMediaPort(port)`, `removeSession(id)`.
- **`MediaRelay`:**
    - **æ•°æ®:** å¦‚ä¸Šæ‰€è¿°çš„ `active_flows_table` (ä¸¤ä¸ªæ–¹å‘çš„è½¬å‘è¡¨)ï¼Œé”®ä¸º Bridge æœ¬åœ°æ¥æ”¶åª’ä½“çš„ç«¯å£ï¼Œå€¼ä¸ºåŒ…å«å®Œæ•´è½¬å‘è·¯å¾„å’Œå¤„ç†è§„åˆ™çš„ç»“æ„ä½“ã€‚**è¿™äº›è¡¨å¿…é¡»æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚**
    - **å‡½æ•°:** `addFlow(sessionId, zkLocalPort, zkRemoteEp, tmsLocalPort, tmsRemoteEp, zkToTmsHeaderProc, tmsToZkHeaderProc)`, `removeFlow(sessionId_or_ports)`, `onUdpPacketReceived(buffer, len, localRecvPort, remoteSenderEp)`.
- **`ZkListener` (in `zk_interface`):**
    - **æ•°æ®:** `std::vector<std::unique_ptr<AsyncUDPSocket>> zk_listening_sockets;` (10ä¸ªï¼Œæ¯ä¸ªå¯¹åº”ä¸€ä¸ªZKçš„ä¿¡ä»¤/åª’ä½“å…¥å£)ã€‚
    - **å‡½æ•°:** `startListening()`, `onDataReceived(socket_idx, data, remote_ep)` (å›è°ƒï¼Œç”±æ­¤åˆ›å»ºä»»åŠ¡äº¤å·¥ä½œçº¿ç¨‹æ± )ã€‚

---

### 6. åº“çš„ä½¿ç”¨å»ºè®®

- **JSON åº“ (å¦‚ nlohmann/json for Modern C++):**
    - **ç”¨é€”:** åœ¨ `ConfigManager` ä¸­ç”¨äºè§£æ `.json` æ ¼å¼çš„é…ç½®æ–‡ä»¶ï¼ˆcué…ç½®è¡¨, cuå’Œtarget_idæ˜ å°„è¡¨, tms/zk ip portç­‰ï¼‰ã€‚
    - **é›†æˆ:** `ConfigManager` ä¾èµ–æ­¤åº“ã€‚
- **spdlog:**
    - **ç”¨é€”:** åœ¨æ•´ä¸ªåº”ç”¨ç¨‹åºä¸­æä¾›é«˜æ€§èƒ½çš„ã€å¯é…ç½®çš„æ—¥å¿—è®°å½•ã€‚
    - **é›†æˆ:** åˆ›å»ºä¸€ä¸ªå…¨å±€å¯è®¿é—®çš„ `LoggerWrapper` æˆ–ç›´æ¥åœ¨å„æ¨¡å—ä¸­ä½¿ç”¨ `spdlog` å®ä¾‹ã€‚æ—¥å¿—çº§åˆ«åº”å¯é…ç½®ã€‚
- **Redis (ç”¨äºä¸»å¤‡å®¹ç¾ - å¯é€‰çš„å¢å¼ºåŠŸèƒ½):**
    - **ç”¨é€”:**
        1. **ä¼šè¯çŠ¶æ€åŒæ­¥/æŒä¹…åŒ–:** å½“ `Session` å¯¹è±¡çš„çŠ¶æ€å‘ç”Ÿå…³é”®å˜åŒ–ï¼ˆåˆ›å»ºã€æ¿€æ´»ã€åª’ä½“ä¿¡æ¯æ›´æ–°ã€æ‹†é™¤ï¼‰æ—¶ï¼Œå¯ä»¥å°†è¿™äº›çŠ¶æ€å¼‚æ­¥åœ°å†™å…¥ Redisã€‚
        2. **ä¸»å¤‡åˆ‡æ¢:** å¦‚æœä¸» Bridge å®ä¾‹æ•…éšœï¼Œå¤‡ç”¨ Bridge å®ä¾‹å¯åŠ¨åå¯ä»¥ä» Redis è¯»å–æ´»åŠ¨çš„ä¼šè¯ä¿¡æ¯ï¼Œå°è¯•æ¢å¤ä¼šè¯ï¼ˆä¾‹å¦‚ï¼Œé‡æ–°å»ºç«‹åª’ä½“è·¯å¾„ï¼Œæˆ–è‡³å°‘çŸ¥é“å“ªäº›ä¼šè¯å­˜åœ¨è¿‡ä»¥ä¾¿è¿›è¡Œæ¸…ç†æˆ–é€šçŸ¥ï¼‰ã€‚
        3. **åˆ†å¸ƒå¼é”/é¢†å¯¼è€…é€‰ä¸¾ (å¯é€‰):** å¦‚æœæœ‰å¤šä¸ªActiveçš„Bridgeå®ä¾‹ï¼ˆæ›´å¤æ‚çš„è´Ÿè½½å‡è¡¡åœºæ™¯ï¼‰ï¼Œæˆ–è€…ä¸¥æ ¼çš„ä¸»å¤‡åˆ‡æ¢ï¼Œå¯èƒ½éœ€è¦ã€‚
        4. **(å¯é€‰) åˆ†å¸ƒå¼ç«¯å£ç®¡ç†:** å¦‚æœå¤šä¸ªBridgeå®ä¾‹éœ€è¦ä»ä¸€ä¸ªå…¨å±€å”¯ä¸€çš„ç«¯å£æ± ä¸­åˆ†é…ç«¯å£ã€‚
    - **é›†æˆ:**
        - `SessionManager` æˆ– `Session` å¯¹è±¡åœ¨çŠ¶æ€å˜æ›´æ—¶ï¼Œä¼šäº§ç”Ÿä¸€ä¸ªä»»åŠ¡ï¼ˆæˆ–ç›´æ¥è°ƒç”¨ï¼‰ä¸ Redis äº¤äº’çš„æ¨¡å—ã€‚
        - éœ€è¦ä¸€ä¸ª `RedisClient` æˆ– `RedisInterface` æ¨¡å—æ¥å°è£…ä¸ Redis æœåŠ¡å™¨çš„é€šä¿¡ (å¯ä»¥ä½¿ç”¨å¦‚ `redis-plus-plus` æˆ– `hiredis` C/C++ å®¢æˆ·ç«¯åº“)ã€‚
        - **è€ƒè™‘ç‚¹:**
            - å†™å…¥ Redis çš„é¢‘ç‡å’Œæ•°æ®é‡ï¼ˆé¿å…æˆä¸ºç“¶é¢ˆï¼‰ã€‚
            - æ•°æ®ä¸€è‡´æ€§ä¸åºåˆ—åŒ–/ååºåˆ—åŒ–ã€‚
            - Redis çš„éƒ¨ç½²å’Œå¯ç”¨æ€§ã€‚
            - ä¼šè¯æ¢å¤çš„å¤æ‚æ€§ï¼ˆé‡æ–°å»ºç«‹ UDP åª’ä½“æµé€šå¸¸æ¯” TCP è¿æ¥æ¢å¤æ›´å¤æ‚ï¼Œå› ä¸ºUDPæ— çŠ¶æ€ï¼‰ã€‚å¯¹äºåª’ä½“ï¼Œå¯èƒ½æ›´å¤šçš„æ˜¯çŸ¥é“ä¼šè¯å­˜åœ¨ï¼Œç„¶åå°è¯•å¿«é€Ÿæ‹†é™¤æˆ–æŒ‡ç¤ºå¯¹ç«¯é‡å»ºã€‚

---

è¿™ä¸ªç»“æ„è®¾è®¡è€ƒè™‘äº†æ‚¨æœ€æ–°çš„éœ€æ±‚å’Œæˆ‘ä»¬ä¹‹å‰çš„è®¨è®ºï¼Œæ—¨åœ¨æä¾›ä¸€ä¸ªæ¸…æ™°ã€é«˜æ•ˆä¸”å¯æ‰©å±•çš„ C++ Bridge ç³»ç»Ÿè“å›¾ã€‚å®é™…å®ç°æ—¶ï¼Œè¿˜éœ€è¦åœ¨å¼‚æ­¥ç¼–ç¨‹ã€é”™è¯¯å¤„ç†ã€çº¿ç¨‹åŒæ­¥ç»†èŠ‚ä¸Šè¿›è¡Œç»†è‡´çš„å·¥ä½œã€‚